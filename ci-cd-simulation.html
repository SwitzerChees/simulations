<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['monospace']
                    },
                }
            }
        }
    </script>
</head>
<body class="m-0 overflow-hidden font-mono">
    <canvas class="block"></canvas>
    <div id="history" class="absolute top-2.5 left-2.5 w-[300px] max-h-[80vh] overflow-y-auto bg-white/90 p-2.5 rounded-md shadow-md">
        <h3 class="m-0 mb-2.5 text-lg font-semibold">CI/CD Pipeline Simulation</h3>
        <div class="mb-2.5 text-sm text-gray-600">Click components to interact</div>
        <div id="historyLog" class="flex flex-col gap-1.5"></div>
    </div>
    <div id="controls" class="absolute top-2.5 right-2.5 bg-white/90 p-2.5 rounded-md shadow-md flex flex-col gap-1.5">
        <button id="commitButton" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded transition-colors duration-200 cursor-pointer">Commit Changes</button>
        <button id="pushButton" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded transition-colors duration-200 cursor-pointer">Git Push</button>
        <button id="createPRButton" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors duration-200 cursor-pointer">Create PR</button>
    </div>
    <div id="status" class="absolute bottom-5 left-1/2 -translate-x-1/2 bg-white/90 px-8 py-4 rounded-md shadow-md text-gray-800 text-lg text-center opacity-0 transition-opacity duration-300">Ready</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // Configuration
        const CONFIG = {
            animations: {
                defaultDuration: 2000,
                buildStep: {
                    phases: [
                        { duration: 1000, progress: 0.2 },  // Initial phase
                        { duration: 1500, progress: 0.5 },  // Middle phase
                        { duration: 1000, progress: 0.8 },  // Almost done
                        { duration: 500, progress: 1.0 }    // Completion
                    ],
                    pauseBetweenPhases: 200
                },
                flow: {
                    particleCount: 25,
                    particleSizeRange: { min: 0.15, max: 0.3 },
                    speed: 0.002,  // Moderate speed
                    rotationSpeed: 0.01,
                    trailLength: 0.4,  // Moderate trail
                    duration: 2000  // Fixed duration for flow animations
                }
            },
            colors: {
                success: 0x4CAF50,
                warning: 0xFFC107,
                error: 0xFF5252,
                inactive: 0xcccccc,
                highlight: 0x2196F3
            }
        };

        // Utility functions
        const utils = {
            delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),

            easeInOutCubic: (t) => t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2,
                
            pulseEffect: (mesh, startIntensity = 1) => {
                const originalIntensity = startIntensity;
                let intensity = originalIntensity;
                let increasing = false;
                let isRunning = true;

                const animate = () => {
                    if (!isRunning) return;

                    if (increasing) {
                        intensity += 0.05;
                        if (intensity >= originalIntensity + 0.5) increasing = false;
                    } else {
                        intensity -= 0.05;
                        if (intensity <= originalIntensity - 0.5) increasing = true;
                    }

                    if (mesh.material) {
                        if (mesh.material.emissiveIntensity !== undefined) {
                            mesh.material.emissiveIntensity = intensity;
                        }
                        if (mesh.material.intensity !== undefined) {
                            mesh.material.intensity = intensity;
                        }
                    }

                    requestAnimationFrame(animate);
                };

                animate();
                return () => {
                    isRunning = false;
                    if (mesh.material) {
                        if (mesh.material.emissiveIntensity !== undefined) {
                            mesh.material.emissiveIntensity = originalIntensity;
                        }
                        if (mesh.material.intensity !== undefined) {
                            mesh.material.intensity = originalIntensity;
                        }
                    }
                };
            },

            animateProgress: async ({ 
                onProgress, 
                duration, 
                easing = utils.easeInOutCubic,
                startValue = 0,
                endValue = 1
            }) => {
                const startTime = Date.now();
                return new Promise(resolve => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easedProgress = easing(progress);
                        const currentValue = startValue + (endValue - startValue) * easedProgress;
                        
                        onProgress(currentValue);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    animate();
                });
            },

            pulseEffect: (mesh, startIntensity, callback) => {
                let running = true;
                const animate = () => {
                    if (!running) return;
                    mesh.material.emissiveIntensity = startIntensity + Math.sin(Date.now() * 0.005) * 0.3;
                    requestAnimationFrame(animate);
                };
                animate();
                return () => { running = false; };
            }
        };

        // Base class for animated entities
        class AnimatedEntity {
            constructor() {
                this.isRunning = false;
                this.stopPulse = null;
            }

            startPulse(mesh, startIntensity) {
                if (this.stopPulse) this.stopPulse();
                this.stopPulse = utils.pulseEffect(mesh, startIntensity);
            }

            stopPulseEffect() {
                if (this.stopPulse) {
                    this.stopPulse();
                    this.stopPulse = null;
                }
            }

            async animateWithPhases(phases, updateFn) {
                for (const phase of phases) {
                    await utils.animateProgress({
                        duration: phase.duration,
                        startValue: phase.start,
                        endValue: phase.end,
                        onProgress: updateFn
                    });
                    if (phase.end < 1) await utils.delay(CONFIG.animations.buildStep.pauseBetweenPhases);
                }
            }
        }

        // Status and history management
        const showStatus = (message) => {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
            historySystem.addAction(message);
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Component focus system
        const focusSystem = {
            currentComponent: null,
            transitionDuration: 1000, // ms
            
            focusComponent: function(component) {
                if (!component || !component.mesh) return;
                this.currentComponent = component;
                
                // First move the camera target
                new TWEEN.Tween(controls.target)
                    .to(component.mesh.position, this.transitionDuration)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();

                // Calculate ideal camera position (15 units back from target)
                const direction = camera.position.clone().sub(controls.target).normalize();
                const targetPosition = component.mesh.position.clone().add(direction.multiplyScalar(15));

                // Move camera position
                new TWEEN.Tween(camera.position)
                    .to(targetPosition, this.transitionDuration)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
            },

            focusSequence: function(fromComponent, toComponent) {
                if (!fromComponent || !toComponent) return;
                
                // Highlight start component
                fromComponent.highlight();
                
                // Start camera movement after a short delay
                setTimeout(() => {
                    this.focusComponent(toComponent);
                    
                    // Remove highlight from start component and highlight end component
                    // halfway through the camera movement
                    setTimeout(() => {
                        fromComponent.mesh.traverse((child) => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        });
                        toComponent.highlight();
                    }, this.transitionDuration / 2);
                }, 500);
            }
        };
        
        // Helper function to clear all highlights
        const clearAllHighlights = () => {
            Object.values(components).forEach(component => {
                if (component && component.mesh) {
                    component.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                }
            });
        };

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Text sprite creation helper
        function createTextSprite(text, position, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.font = '24px Arial';
            context.fillStyle = '#333333';
            context.textAlign = 'center';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(scale * 4, scale * 2, 1);
            return sprite;
        }

        // Enhanced Materials with environment mapping
        const envMap = new THREE.CubeTextureLoader()
            .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
            .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);

        const createMetalMaterial = (color, roughness = 0.2) => {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.9,
                roughness: roughness,
                envMap: envMap,
                envMapIntensity: 1
            });
        };

        // Components
        class Component {
            constructor(createGeometryFn, position, name, color) {
                const group = createGeometryFn(color);
                this.mesh = group;
                this.mesh.position.copy(position);
                this.name = name;
                this.mesh.userData.component = this;

                // Add invisible bounding box for larger hit area
                const boundingBox = new THREE.Box3().setFromObject(group);
                const size = boundingBox.getSize(new THREE.Vector3());
                const boxGeometry = new THREE.BoxGeometry(
                    size.x * 1.75, // 1.75x size for balanced hitbox
                    size.y * 1.75,
                    size.z * 1.75
                );
                const boxMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    side: THREE.BackSide
                });
                this.hitbox = new THREE.Mesh(boxGeometry, boxMaterial);
                this.hitbox.userData.rootComponent = this;
                group.add(this.hitbox);

                // Add component reference to all child meshes
                this.mesh.traverse((child) => {
                    child.userData.rootComponent = this;
                });
                scene.add(this.mesh);

                // Add component label
                const labelPos = position.clone();
                labelPos.y += 3;
                this.label = createTextSprite(name, labelPos);
                scene.add(this.label);
            }

            highlight(permanent = false, color = 0x00ff00) {
                const highlightColor = new THREE.Color(color);
                this.mesh.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        if (!permanent) {
                            const originalColor = child.material.emissive.clone();
                            child.material.emissive = highlightColor;
                            setTimeout(() => {
                                child.material.emissive = originalColor;
                            }, 1000);
                        } else {
                            child.material.emissive = highlightColor;
                        }
                    }
                });
            }
        }

        // Local Git - Repository with branching structure
        const createLocalGit = (color) => {
            const group = new THREE.Group();
            
            // Main cylinder (trunk)
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 3, 8),
                createMetalMaterial(color)
            );
            group.add(trunk);

            // Branches
            for (let i = 0; i < 3; i++) {
                const branch = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 2, 8),
                    createMetalMaterial(color)
                );
                branch.position.y = -0.5 + i;
                branch.rotation.z = Math.PI / 3;
                branch.position.x = 0.8;
                group.add(branch);
            }

            return group;
        };

        // GitHub - Octocat-inspired shape
        const createGitHub = (color) => {
            const group = new THREE.Group();

            // Body (octagon)
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 2, 8),
                createMetalMaterial(color)
            );
            group.add(body);

            // Tentacles
            for (let i = 0; i < 8; i++) {
                const tentacle = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.1, 8, 6),
                    createMetalMaterial(color)
                );
                tentacle.rotation.y = (i / 8) * Math.PI * 2;
                tentacle.position.y = -1;
                group.add(tentacle);
            }

            return group;
        };

        // Build Server - Server rack with glowing components
        const createBuildServer = (color) => {
            const group = new THREE.Group();

            // Main frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(3, 4, 2),
                createMetalMaterial(color, 0.5)
            );
            group.add(frame);

            // Glowing server units
            for (let i = 0; i < 4; i++) {
                const unit = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.5, 1.5),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                unit.position.y = -1.5 + i;
                group.add(unit);
            }

            return group;
        };

        // Test Environment - Molecular structure
        const createTestEnv = (color) => {
            const group = new THREE.Group();

            // Central sphere
            const center = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                createMetalMaterial(color)
            );
            group.add(center);

            // Orbiting test nodes
            for (let i = 0; i < 4; i++) {
                const orbit = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 4) * Math.PI * 2;
                orbit.position.set(
                    Math.cos(angle) * 1.5,
                    Math.sin(angle) * 1.5,
                    0
                );
                group.add(orbit);

                // Connection to center
                const line = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                    createMetalMaterial(color)
                );
                line.position.set(
                    Math.cos(angle) * 0.75,
                    Math.sin(angle) * 0.75,
                    0
                );
                line.lookAt(orbit.position);
                group.add(line);
            }

            return group;
        };

        // Production - Cloud-like structure
        const createProduction = (color) => {
            const group = new THREE.Group();

            // Main cloud shapes
            const shapes = [
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
            ];

            const positions = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-1, 0.2, 0),
                new THREE.Vector3(1, 0.2, 0),
            ];

            shapes.forEach((shape, i) => {
                const cloud = new THREE.Mesh(
                    shape,
                    createMetalMaterial(color)
                );
                cloud.position.copy(positions[i]);
                group.add(cloud);
            });

            // Add some smaller detail spheres
            for (let i = 0; i < 5; i++) {
                const detail = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 5) * Math.PI * 2;
                detail.position.set(
                    Math.cos(angle) * 1.2,
                    Math.sin(angle) * 0.3 + 0.5,
                    0
                );
                group.add(detail);
            }

            return group;
        };

        // Create GitHub Actions component
        const createGitHubActions = (color) => {
            const group = new THREE.Group();

            // Central hexagon
            const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 6);
            const material = createMetalMaterial(color);
            const hexagon = new THREE.Mesh(geometry, material);
            hexagon.rotation.x = Math.PI / 2;
            group.add(hexagon);

            // Orbiting gears
            const gearCount = 6;
            for (let i = 0; i < gearCount; i++) {
                const gearGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
                const gear = new THREE.Mesh(gearGeometry, material);
                const angle = (i / gearCount) * Math.PI * 2;
                gear.position.x = Math.cos(angle) * 2;
                gear.position.z = Math.sin(angle) * 2;
                gear.rotation.x = Math.PI / 2;
                group.add(gear);
            }

            return group;
        };

        // Create Pull Request component
        const createPullRequest = (color) => {
            const group = new THREE.Group();

            // PR document shape
            const document = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2, 0.2),
                createMetalMaterial(color)
            );
            group.add(document);

            // Add lines of "text"
            const textMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.1, 0.1),
                    textMat
                );
                line.position.y = 0.5 - (i * 0.4);
                group.add(line);
            }

            return group;
        };

        // Build Server Status Display
        const createBuildStatus = (text, position, color) => {
            const label = createTextSprite(text, position);
            label.visible = false;
            scene.add(label);
            return label;
        };

        // Create developer component
        const createDeveloper = (color) => {
            const group = new THREE.Group();

            // Developer head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 32, 32),
                createMetalMaterial(color)
            );
            head.position.y = 1.2;
            group.add(head);

            // Developer body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.8, 2, 8),
                createMetalMaterial(color)
            );
            group.add(body);

            // Developer arms
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const leftArm = new THREE.Mesh(armGeometry, createMetalMaterial(color));
            leftArm.position.set(-0.8, 0.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, createMetalMaterial(color));
            rightArm.position.set(0.8, 0.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            group.add(rightArm);

            return group;
        };

        // Create components with new layout
        const components = {
            developer: new Component(
                createDeveloper,
                new THREE.Vector3(-24, 0, 0),
                'Developer',
                0x9C27B0
            ),
            local: new Component(
                createLocalGit,
                new THREE.Vector3(-16, 0, 0),
                'Local Git',
                0x4CAF50
            ),
            github: new Component(
                createGitHub,
                new THREE.Vector3(-8, 0, 0),
                'GitHub',
                0x2196F3
            ),
            githubActions: new Component(
                createGitHubActions,
                new THREE.Vector3(-8, 6, 0),
                'GitHub Actions',
                0xFFC107
            ),
            buildServer: new Component(
                createBuildServer,
                new THREE.Vector3(-8, -8, 0),
                'Build Server',
                0xFF9800
            ),
            test: new Component(
                createTestEnv,
                new THREE.Vector3(8, 0, 0),
                'Test Env',
                0x9C27B0
            ),
            prod: new Component(
                createProduction,
                new THREE.Vector3(16, 0, 0),
                'Production',
                0xF44336
            )
        };

        // Build Step visualization
        class BuildStep extends AnimatedEntity {
            constructor(name, position, color) {
                super();
                this.name = name;
                this.position = position;
                this.color = color;
                this.progress = 0;
                this.isComplete = false;
                this.isSuccess = false;

                // Create the step visualization
                const geometry = new THREE.BoxGeometry(2, 0.5, 0.5);
                const material = new THREE.MeshPhongMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.5,
                    emissive: this.color,
                    emissiveIntensity: 0.2
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);

                // Create progress indicator (starts invisible)
                const progressGeometry = new THREE.BoxGeometry(0.1, 0.7, 0.7);
                const progressMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                });
                this.progressMesh = new THREE.Mesh(progressGeometry, progressMaterial);
                this.progressMesh.position.copy(position);
                this.progressMesh.position.x -= 1; // Start from the left
                this.progressMesh.visible = false;
                scene.add(this.progressMesh);

                // Create label
                this.label = createTextSprite(name, new THREE.Vector3(position.x, position.y + 0.5, position.z));
                scene.add(this.label);
            }

            async run(shouldSucceed = true) {
                this.isRunning = true;
                this.progress = 0;
                this.progressMesh.visible = true;
                this.mesh.material.opacity = 0.8;

                // Start pulsing effect
                this.startPulse(this.mesh, this.mesh.material.emissiveIntensity);

                // Convert config phases to animation phases
                const phases = CONFIG.animations.buildStep.phases.map((phase, index, arr) => ({
                    duration: phase.duration,
                    start: index === 0 ? 0 : arr[index - 1].progress,
                    end: phase.progress
                }));

                // Animate through phases
                await this.animateWithPhases(phases, (progress) => {
                    this.progress = progress;
                    this.progressMesh.position.x = this.position.x - 1 + (progress * 2);
                });

                this.isRunning = false;
                this.stopPulseEffect();
                this.complete(shouldSucceed);
            }

            complete(success) {
                this.isComplete = true;
                this.isSuccess = success;
                this.isRunning = false;
                this.progressMesh.visible = false;

                // Update appearance based on result
                const resultColor = success ? CONFIG.colors.success : CONFIG.colors.error;
                this.mesh.material.color.setHex(resultColor);
                this.mesh.material.emissive.setHex(resultColor);
                this.label.material.map.dispose();
                this.label = createTextSprite(
                    `${this.name} ${success ? '✓' : '✗'}`,
                    new THREE.Vector3(this.position.x, this.position.y + 0.5, this.position.z)
                );
            }

            reset() {
                this.progress = 0;
                this.isRunning = false;
                this.isComplete = false;
                this.isSuccess = false;
                this.progressMesh.visible = false;
                this.mesh.material.color.setHex(this.color);
                this.mesh.material.emissive.setHex(this.color);
                this.mesh.material.opacity = 0.5;
                this.stopPulseEffect();
                this.label.material.map.dispose();
                this.label = createTextSprite(
                    this.name,
                    new THREE.Vector3(this.position.x, this.position.y + 0.5, this.position.z)
                );
            }
        }

        // Create build steps
        const buildSteps = {
            lint: new BuildStep('Linting', new THREE.Vector3(-10, -6, 0), 0xFFEB3B),
            test: new BuildStep('Testing', new THREE.Vector3(-8, -6, 0), 0x4CAF50),
            build: new BuildStep('Building', new THREE.Vector3(-6, -6, 0), 0x2196F3)
        };

        let activePR = null;

        // Create connection lines and action labels
        const connectionMaterials = {
            inactive: new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 }),  // Light gray for inactive
            active: new THREE.LineBasicMaterial({ color: 0x4CAF50, linewidth: 2 })     // Softer green for active
        };
        const connections = [];
        const actionLabels = [];

        function createConnection(start, end, actionText) {
            // Create connection line
            const points = [];
            points.push(start.mesh.position);
            points.push(end.mesh.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, connectionMaterials.inactive);
            line.userData.originalColor = connectionMaterials.inactive;
            scene.add(line);
            connections.push(line);

            // Create action label
            const midPoint = new THREE.Vector3().lerpVectors(start.mesh.position, end.mesh.position, 0.5);
            midPoint.y += 1;
            const actionLabel = createTextSprite(actionText, midPoint, 0.7);
            scene.add(actionLabel);
            actionLabels.push(actionLabel);

            return line;
        }

        // Create connections between components with action labels
        const pathConnections = {
            devToLocal: createConnection(components.developer, components.local, 'code'),
            gitPush: createConnection(components.local, components.github, 'git push'),
            prToActions: createConnection(components.github, components.githubActions, 'PR Trigger'),
            actionsToBuild: createConnection(components.githubActions, components.buildServer, 'CI Jobs'),
            buildToTest: createConnection(components.buildServer, components.test, 'Deploy to Test'),
            testToProd: createConnection(components.test, components.prod, 'Deploy to Prod'),
            feedbackToDev: createConnection(components.buildServer, components.developer, 'CI Feedback')
        };

        // Function to update path colors
        function updatePathColors(completedPaths) {
            Object.keys(pathConnections).forEach(path => {
                pathConnections[path].material = completedPaths.includes(path) ? 
                    connectionMaterials.active : connectionMaterials.inactive;
            });
        }

        // Particle system for code flow
        class ParticleFlow extends AnimatedEntity {
            constructor(start, end, color = CONFIG.colors.success) {
                super();
                this.startPos = typeof start === 'object' && start.mesh ? start.mesh.position : start;
                this.endPos = typeof end === 'object' && end.mesh ? end.mesh.position : end;
                this.color = color;
                this.particles = [];
                this.progress = 0;
                this.onComplete = null;
                this.createParticles();
            }

            createParticles() {
                const particleCount = CONFIG.animations.flow.particleCount;
                const sizeRange = CONFIG.animations.flow.particleSizeRange;
                
                const geometries = [
                    (size) => new THREE.OctahedronGeometry(size),
                    (size) => new THREE.TetrahedronGeometry(size),
                    (size) => new THREE.IcosahedronGeometry(size * 0.8),
                    (size) => {
                        const geometry = new THREE.SphereGeometry(size * 0.7, 8, 8);
                        geometry.scale(1, 0.5, 1); // Create ellipsoid
                        return geometry;
                    }
                ];
                
                for (let i = 0; i < particleCount; i++) {
                    const size = sizeRange.min + Math.random() * (sizeRange.max - sizeRange.min);
                    const geometryFn = geometries[Math.floor(Math.random() * geometries.length)];
                    const geometry = geometryFn(size);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.9,
                        emissive: this.color,
                        emissiveIntensity: 0.7,
                        shininess: 50
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    
                    // Random initial rotation
                    particle.rotation.x = Math.random() * Math.PI * 2;
                    particle.rotation.y = Math.random() * Math.PI * 2;
                    particle.rotation.z = Math.random() * Math.PI * 2;
                    
                    // Add rotation speeds
                    particle.userData.rotationSpeed = {
                        x: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed,
                        y: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed,
                        z: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed
                    };
                    
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        offset: i * (1 / particleCount)  // Evenly spaced particles
                    });
                }
            }

            startFlow(onComplete) {
                this.cleanup(); // Clean up any existing particles
                this.createParticles(); // Create fresh particles
                this.isRunning = true;
                this.progress = 0;
                this.startTime = Date.now();
                this.particles.forEach(p => {
                    p.mesh.visible = true;
                });
                this.onComplete = onComplete;
            }

            stop() {
                this.particles.forEach(p => {
                    p.mesh.visible = false;
                });
                this.stopPulseEffect();
                if (this.onComplete) this.onComplete();
                this.isRunning = false;
            }

            update() {
                if (!this.isRunning) return;

                // Calculate progress based on time for consistent speed
                const elapsed = Date.now() - this.startTime;
                this.progress = Math.min(elapsed / CONFIG.animations.flow.duration, 1 + CONFIG.animations.flow.trailLength);

                this.particles.forEach(particle => {
                    let particleProgress = this.progress - particle.offset;
                    
                    // Keep particles visible until the end of their trail
                    if (particleProgress > 1) {
                        particleProgress = Math.min(particleProgress, 1 + CONFIG.animations.flow.trailLength);
                    } else if (particleProgress < 0) {
                        particleProgress = 0;
                    }
                    
                    // Position interpolation
                    const normalizedProgress = Math.min(particleProgress, 1);
                    const easedProgress = utils.easeInOutCubic(normalizedProgress);
                    particle.mesh.position.lerpVectors(
                        this.startPos,
                        this.endPos,
                        easedProgress
                    );

                    // Rotate the particle
                    const rotSpeed = particle.mesh.userData.rotationSpeed;
                    particle.mesh.rotation.x += rotSpeed.x;
                    particle.mesh.rotation.y += rotSpeed.y;
                    particle.mesh.rotation.z += rotSpeed.z;

                    // Fade calculation
                    let fade = 1.0;
                    if (particleProgress <= 0.2) { // Fade in
                        fade = particleProgress / 0.2;
                    } else if (particleProgress >= 1.0) { // Fade out
                        fade = 1.0 - ((particleProgress - 1.0) / CONFIG.animations.flow.trailLength);
                    }
                    
                    fade = utils.easeInOutCubic(fade);
                    particle.mesh.visible = fade > 0;
                    particle.mesh.material.opacity = fade * 0.9;
                    particle.mesh.material.emissiveIntensity = 0.4 + fade * 0.6;
                });

                if (this.progress >= 1 + CONFIG.animations.flow.trailLength) {
                    this.stop();
                }
            }

            cleanup() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.mesh.material) {
                        p.mesh.material.dispose();
                    }
                    if (p.mesh.geometry) {
                        p.mesh.geometry.dispose();
                    }
                });
                this.particles = [];
                this.isRunning = false;
            }
        }

        // GitHub Actions visualization
        class GitHubActions {
            constructor(position) {
                this.position = position.clone();
                this.position.y += 1;
                this.processes = ['lint', 'test', 'build'];
                this.currentProcess = -1;
                this.processLabels = this.processes.map((process, index) => {
                    const label = createTextSprite(process, 
                        new THREE.Vector3(position.x - 1 + index, position.y + 1, position.z));
                    label.visible = false;
                    scene.add(label);
                    return label;
                });
            }

            async runProcess() {
                this.currentProcess = -1;
                for (let i = 0; i < this.processes.length; i++) {
                    this.currentProcess = i;
                    this.processLabels[i].visible = true;
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ⏳`,
                        this.processLabels[i].position
                    );
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ✓`,
                        this.processLabels[i].position
                    );
                }
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            reset() {
                this.processLabels.forEach(label => {
                    label.visible = false;
                });
                this.currentProcess = -1;
            }
        }



        // Create flows for each connection
        const flows = {
            devToLocal: new ParticleFlow(components.developer.mesh.position, components.local.mesh.position, 0x4CAF50),
            gitPush: new ParticleFlow(components.local.mesh.position, components.github.mesh.position, 0x4CAF50),
            prToActions: new ParticleFlow(new THREE.Vector3(-4, 0, 0), new THREE.Vector3(-8, 6, 0), 0xFFC107),  // PR to GitHub Actions
            actionsToBuild: new ParticleFlow(new THREE.Vector3(-8, 6, 0), new THREE.Vector3(-8, -8, 0), 0xFF9800),  // GitHub Actions to Build Server
            deployTest: new ParticleFlow(components.buildServer.mesh.position, components.test.mesh.position, 0x9C27B0),
            deployProd: new ParticleFlow(components.test.mesh.position, components.prod.mesh.position, 0xF44336),
            feedbackToDev: new ParticleFlow(components.buildServer.mesh.position, components.developer.mesh.position, 0xFF0000)  // Red for failure feedback
        };

        const githubActions = new GitHubActions(components.github.mesh.position);

        // History log system
        const historySystem = {
            actions: [],
            addAction: function(action) {
                const timestamp = new Date().toLocaleTimeString();
                const actionItem = { timestamp, action, type: pipelineState.currentAction };
                this.actions.push(actionItem);
                this.updateHistoryLog();
            },
            updateHistoryLog: function() {
                const historyLog = document.getElementById('historyLog');
                const actionItem = this.actions[this.actions.length - 1];
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-2 bg-gray-50 rounded border-l-4 border-blue-500 mb-1.5 hover:bg-gray-100 transition-colors duration-200';
                
                const timeSpan = document.createElement('span');
                timeSpan.className = 'text-gray-600 text-sm';
                timeSpan.textContent = actionItem.timestamp;
                
                const actionSpan = document.createElement('div');
                actionSpan.className = 'mt-0.5';
                actionSpan.textContent = actionItem.action;
                
                const replayButton = document.createElement('button');
                replayButton.textContent = 'Replay';
                replayButton.className = 'mt-1.5 px-2 py-1 bg-green-500 hover:bg-green-600 text-white rounded text-xs cursor-pointer transition-colors duration-200';
                replayButton.onclick = () => this.replayAction(actionItem);
                
                itemDiv.appendChild(timeSpan);
                itemDiv.appendChild(actionSpan);
                itemDiv.appendChild(replayButton);
                historyLog.appendChild(itemDiv);
                
                // Scroll to bottom
                historyLog.scrollTop = historyLog.scrollHeight;
            },
            replayAction: async function(actionItem) {
                if (pipelineState.isProcessing) {
                    alert('Please wait for the current action to complete');
                    return;
                }
                
                switch(actionItem.type) {
                    case 'commit':
                        await handleCommit();
                        break;
                    case 'push':
                        if (pipelineState.hasLocalChanges) {
                            pipelineState.currentAction = 'push';
                            components.local.highlight();
                            flows.gitPush.startFlow(() => {
                                showStatus('Code pushed successfully! Click GitHub to create PR');
                                pipelineState.canPush = false;
                                pipelineState.canCreatePR = true;
                                pipelineState.isProcessing = false;
                            });
                        }
                        break;
                    case 'pr':
                        if (pipelineState.canCreatePR) {
                            handlePRCreation();
                        }
                        break;
                }
            }
        };

        // Pipeline Flow Manager
        class FlowManager {
            constructor() {
                this.state = {
                    canPush: true,
                    canCreatePR: false,
                    isProcessing: false,
                    canCommit: true,
                    hasLocalChanges: false,
                    currentAction: null
                };
            }

            async executeStep({ 
                status, 
                component = null,
                flow = null, 
                action = null
            }) {
                showStatus(status);
                
                if (flow && component) {
                    // Start flow and highlighting together
                    clearAllHighlights();
                    component.highlight();
                    focusSystem.focusComponent(component);
                    
                    return new Promise((resolve) => {
                        flow.startFlow(() => {
                            resolve();
                        });
                    });
                } else if (component) {
                    clearAllHighlights();
                    component.highlight();
                    focusSystem.focusComponent(component);
                }

                if (action) {
                    await action();
                }
            }

            async runPipeline(steps) {
                this.state.isProcessing = true;
                
                try {
                    for (const step of steps) {
                        await this.executeStep(step);
                    }
                    return true;
                } catch (error) {
                    console.error('Pipeline error:', error);
                    showStatus(`Pipeline failed: ${error.message}`);
                    return false;
                } finally {
                    this.state.isProcessing = false;
                }
            }
        }

        // Initialize Flow Manager
        const flowManager = new FlowManager();
        const pipelineState = flowManager.state;



        // Commit button handler
        const handleCommit = async () => {
            if (!pipelineState.canCommit || pipelineState.isProcessing) {
                showStatus('Please wait for the current process to complete...');
                return;
            }

            pipelineState.currentAction = 'commit';
            updatePathColors(['devToLocal']);

            const commitSteps = [
                {
                    status: 'Developer committing changes...',
                    component: components.developer,
                    flow: flows.devToLocal,
                    delayTime: 1500
                },
                {
                    status: 'Changes committed to local repository',
                    component: components.local,
                    action: () => {
                        pipelineState.hasLocalChanges = true;
                        pipelineState.canPush = true;
                    }
                }
            ];

            await flowManager.runPipeline(commitSteps);
        };

        // Handle commit button click
        document.getElementById('commitButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing) {
                handleCommit();
                focusSystem.focusSequence(components.developer, components.local);
            }
        });

        // Handle push button click
        document.getElementById('pushButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canPush && pipelineState.hasLocalChanges) {
                handleGitPush();
                focusSystem.focusSequence(components.local, components.github);
            } else {
                showStatus('Cannot push: Ensure you have committed changes and no process is running');
            }
        });

        // Handle PR button click
        document.getElementById('createPRButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canCreatePR) {
                handlePRCreation();
                focusSystem.focusSequence(components.github, components.githubActions);
            } else {
                showStatus('Cannot create PR: Ensure you have pushed changes and no process is running');
            }
        });

        // Build step helper function
        const runBuildStep = async (status, message, duration) => {
            return new Promise((resolve, reject) => {
                showStatus(message);
                status.visible = true;
                setTimeout(() => {
                    // 80% chance of success
                    if (Math.random() > 0.2) {
                        status.material.color.setHex(0x4CAF50);
                        resolve();
                    } else {
                        status.material.color.setHex(0xFF5252);
                        reject(new Error('Build step failed'));
                    }
                }, duration);
            });
        };

        // PR Creation Handler
        let simulateFailure = false; // Control whether the pipeline should fail

        const handlePRCreation = async () => {
            pipelineState.currentAction = 'pr';
            pipelineState.canCreatePR = false;
            updatePathColors(['prToActions']);

            // Reset all build steps
            Object.values(buildSteps).forEach(step => step.reset());

            // Create PR visualization
            if (activePR) {
                scene.remove(activePR.mesh);
                scene.remove(activePR.label);
            }
            activePR = new Component(
                createPullRequest,
                new THREE.Vector3(-4, 0, 0),
                'Pull Request',
                0xFFEB3B
            );

            const prSteps = [
                {
                    status: 'Creating Pull Request...',
                    component: components.github,
                    action: () => activePR.highlight(),
                    delayTime: 1000
                },
                {
                    status: 'PR triggering GitHub Actions...',
                    component: components.githubActions,
                    flow: flows.prToActions,
                    delayTime: 2000
                },
                {
                    status: 'Starting CI Pipeline...',
                    component: components.buildServer,
                    flow: flows.actionsToBuild,
                    delayTime: 1000
                },
                {
                    status: 'Running linter...',
                    action: async () => {
                        await buildSteps.lint.run(!simulateFailure);
                        if (!buildSteps.lint.isSuccess) throw new Error('Linting failed');
                    },
                    delayTime: 1000
                },
                {
                    status: 'Running tests...',
                    action: async () => {
                        await buildSteps.test.run(!simulateFailure);
                        if (!buildSteps.test.isSuccess) throw new Error('Tests failed');
                    },
                    delayTime: 1000
                },
                {
                    status: 'Building project...',
                    action: async () => {
                        await buildSteps.build.run(!simulateFailure);
                        if (!buildSteps.build.isSuccess) throw new Error('Build failed');
                    },
                    delayTime: 1000
                },
                {
                    status: 'Deploying to test environment...',
                    component: components.test,
                    flow: flows.deployTest,
                    delayTime: 2000
                },
                {
                    status: 'Deploying to production...',
                    component: components.prod,
                    flow: flows.deployProd,
                    delayTime: 2000
                },
                {
                    status: 'Pipeline completed successfully!',
                    action: () => {
                        pipelineState.canCommit = true;
                    },
                    delayTime: 500
                }
            ];

            try {
                await flowManager.runPipeline(prSteps);
            } catch (error) {
                console.error('Error in PR creation:', error);
                flows.feedbackToDev.startFlow();
                await utils.delay(2000);
                flows.feedbackToDev.stop();
                pipelineState.canCommit = true;
            }
        };

        // Git push handler
        const handleGitPush = async () => {
            pipelineState.currentAction = 'push';
            updatePathColors(['gitPush']);

            const pushSteps = [
                {
                    status: 'Pushing to GitHub...',
                    component: components.local,
                    flow: flows.gitPush,
                    delayTime: 1500
                },
                {
                    status: 'Changes pushed to GitHub',
                    component: components.github,
                    delayTime: 1000,
                    action: () => {
                        pipelineState.canPush = false;
                        pipelineState.canCreatePR = true;
                        pipelineState.hasLocalChanges = false;
                    }
                }
            ];

            await flowManager.runPipeline(pushSteps);
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            TWEEN.update();

            // Update flows
            Object.values(flows).forEach(flow => {
                if (flow.isRunning) {
                    flow.update();
                }
            });

            // Update labels to face camera
            Object.values(components).forEach(component => {
                component.label.quaternion.copy(camera.quaternion);
            });
            actionLabels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle component clicking and hovering
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredComponent = null;
        let mouseDownComponent = null;

        // Helper function to find component at mouse position
        const findComponentAtMouse = (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const allMeshes = [];
            scene.traverse((object) => {
                if (object.isMesh) {
                    allMeshes.push(object);
                }
            });
            const intersects = raycaster.intersectObjects(allMeshes);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                let current = object;
                while (current && !current.userData.rootComponent) {
                    current = current.parent;
                }
                if (current && current.userData.rootComponent) {
                    return current.userData.rootComponent;
                }
            }
            return null;
        };

        // Mouse move handler for hover effect
        window.addEventListener('mousemove', (event) => {
            const foundComponent = findComponentAtMouse(event);

            // Update hover highlighting
            if (foundComponent !== hoveredComponent) {
                // Remove highlight from previously hovered component
                if (hoveredComponent) {
                    hoveredComponent.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                }
                // Add highlight to newly hovered component
                if (foundComponent) {
                    foundComponent.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x444444);
                        }
                    });
                }
                hoveredComponent = foundComponent;
            }
        });

        // Mouse down handler
        window.addEventListener('mousedown', (event) => {
            mouseDownComponent = findComponentAtMouse(event);
        });

        // Mouse up handler
        window.addEventListener('mouseup', async (event) => {
            const mouseUpComponent = findComponentAtMouse(event);
            
            // Only trigger if mouseup is on the same component as mousedown
            if (mouseUpComponent && mouseUpComponent === mouseDownComponent && !pipelineState.isProcessing) {
                focusSystem.focusComponent(mouseUpComponent);
                animate();
            }
            
            mouseDownComponent = null;
        });

        animate();
    </script>
</body>
</html>