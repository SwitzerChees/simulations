<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['monospace']
                    },
                }
            }
        }
    </script>
</head>
<body class="m-0 overflow-hidden font-mono">
    <canvas class="block"></canvas>
    <div id="history" class="absolute top-2.5 left-2.5 w-[300px] max-h-[80vh] overflow-y-auto bg-white/90 p-2.5 rounded-md shadow-md">
        <h3 class="m-0 mb-2.5 text-lg font-semibold">CI/CD Pipeline Simulation</h3>
        <div class="mb-2.5 text-sm text-gray-600">Pipeline Actions</div>
        <div id="historyLog" class="flex flex-col gap-1.5"></div>
    </div>
    <div id="componentSelector" class="absolute bottom-4 left-4 bg-white/90 p-2.5 rounded-md shadow-md">
        <h4 class="m-0 mb-2 text-sm font-medium text-gray-600">Focus Component:</h4>
        <div class="flex flex-wrap gap-2 max-w-[600px]"></div>
    </div>
    <div id="controls" class="absolute top-2.5 right-2.5 bg-white/90 p-2.5 rounded-md shadow-md flex flex-col gap-1.5">
        <div class="flex flex-col gap-2">
            <button id="commitButton" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded transition-colors duration-200 cursor-pointer">Commit Changes</button>
            <div class="flex flex-col gap-1 text-sm bg-gray-100 p-2 rounded">
                <label class="flex items-center gap-1 cursor-pointer hover:text-gray-700">
                    <input type="checkbox" id="lintingCheck" checked>
                    <span>Passes Linting</span>
                </label>
                <label class="flex items-center gap-1 cursor-pointer hover:text-gray-700">
                    <input type="checkbox" id="testingCheck" checked>
                    <span>Passes Tests</span>
                </label>
                <label class="flex items-center gap-1 cursor-pointer hover:text-gray-700">
                    <input type="checkbox" id="buildingCheck" checked>
                    <span>Builds Successfully</span>
                </label>
            </div>
        </div>
        <button id="pushButton" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded transition-colors duration-200 cursor-pointer">Git Push</button>
        <button id="createPRButton" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors duration-200 cursor-pointer">Create PR</button>
    </div>
    <div id="status" class="absolute bottom-5 left-1/2 -translate-x-1/2 bg-white/90 px-8 py-4 rounded-md shadow-md text-gray-800 text-lg text-center opacity-0 transition-opacity duration-300">Ready</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // Configuration
        const CONFIG = {
            animations: {
                defaultDuration: 2000,
                buildStep: {
                    phases: [
                        { duration: 1000, progress: 0.2 },  // Initial phase
                        { duration: 1500, progress: 0.5 },  // Middle phase
                        { duration: 1000, progress: 0.8 },  // Almost done
                        { duration: 500, progress: 1.0 }    // Completion
                    ],
                    pauseBetweenPhases: 200
                },
                flow: {
                    particleCount: 35,  // Increased for better visibility
                    particleSizeRange: { min: 0.2, max: 0.4 },  // Larger particles
                    speed: 0.003,  // Slightly faster
                    rotationSpeed: 0.015,
                    trailLength: 0.4,  // Longer trail for better visibility
                    duration: 2000,     // Faster feedback
                    fadeInDuration: 0.15, // Smoother fade in
                    errorParticles: {
                        count: 45,  // More particles for errors
                        sizeRange: { min: 0.25, max: 0.5 },
                        speed: 0.004,
                        pulseIntensity: 1.5
                    }
                }
            },
            colors: {
                success: 0x4CAF50,
                warning: 0xFFC107,
                error: 0xFF5252,
                inactive: 0xcccccc,
                highlight: 0x2196F3
            }
        };

        // Utility functions
        const utils = {
            delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),

            easeInOutCubic: (t) => t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2,
                
            pulseEffect: (mesh, startIntensity = 1) => {
                const originalIntensity = startIntensity;
                let intensity = originalIntensity;
                let increasing = false;
                let isRunning = true;

                const animate = () => {
                    if (!isRunning) return;

                    if (increasing) {
                        intensity += 0.05;
                        if (intensity >= originalIntensity + 0.5) increasing = false;
                    } else {
                        intensity -= 0.05;
                        if (intensity <= originalIntensity - 0.5) increasing = true;
                    }

                    if (mesh.material) {
                        if (mesh.material.emissiveIntensity !== undefined) {
                            mesh.material.emissiveIntensity = intensity;
                        }
                        if (mesh.material.intensity !== undefined) {
                            mesh.material.intensity = intensity;
                        }
                    }

                    requestAnimationFrame(animate);
                };

                animate();
                return () => {
                    isRunning = false;
                    if (mesh.material) {
                        if (mesh.material.emissiveIntensity !== undefined) {
                            mesh.material.emissiveIntensity = originalIntensity;
                        }
                        if (mesh.material.intensity !== undefined) {
                            mesh.material.intensity = originalIntensity;
                        }
                    }
                };
            },

            animateProgress: async ({ 
                onProgress, 
                duration, 
                easing = utils.easeInOutCubic,
                startValue = 0,
                endValue = 1
            }) => {
                const startTime = Date.now();
                return new Promise(resolve => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easedProgress = easing(progress);
                        const currentValue = startValue + (endValue - startValue) * easedProgress;
                        
                        onProgress(currentValue);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    animate();
                });
            },

            pulseEffect: (mesh, startIntensity, callback) => {
                let running = true;
                const animate = () => {
                    if (!running) return;
                    mesh.material.emissiveIntensity = startIntensity + Math.sin(Date.now() * 0.005) * 0.3;
                    requestAnimationFrame(animate);
                };
                animate();
                return () => { running = false; };
            }
        };

        // Base class for animated entities
        class AnimatedEntity {
            constructor() {
                this.isRunning = false;
                this.stopPulse = null;
            }

            startPulse(mesh, startIntensity) {
                if (this.stopPulse) this.stopPulse();
                this.stopPulse = utils.pulseEffect(mesh, startIntensity);
            }

            stopPulseEffect() {
                if (this.stopPulse) {
                    this.stopPulse();
                    this.stopPulse = null;
                }
            }

            async animateWithPhases(phases, updateFn) {
                for (const phase of phases) {
                    await utils.animateProgress({
                        duration: phase.duration,
                        startValue: phase.start,
                        endValue: phase.end,
                        onProgress: updateFn
                    });
                    if (phase.end < 1) await utils.delay(CONFIG.animations.buildStep.pauseBetweenPhases);
                }
            }
        }

        // Status and history management
        const showStatus = (message) => {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
            historySystem.addAction(message);
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Smooth camera tracking system
        class CameraTracker {
            constructor(camera, controls) {
                this.camera = camera;
                this.controls = controls;
                this.targetPosition = camera.position.clone();
                this.targetLookAt = new THREE.Vector3();
                this.currentComponent = null;
                this.isTransitioning = false;
                this.transitionDuration = 1500; // ms
                
                // Store original control settings
                this.originalDamping = {
                    enableDamping: controls.enableDamping,
                    dampingFactor: controls.dampingFactor
                };
            }

            async focusComponent(component) {
                if (!component || !component.mesh) return;
                
                // Wait for any existing transition to complete
                if (this.isTransitioning) {
                    await new Promise(resolve => {
                        const checkTransition = () => {
                            if (!this.isTransitioning) resolve();
                            else setTimeout(checkTransition, 10);
                        };
                        checkTransition();
                    });
                }
                
                this.currentComponent = component;
                
                // Calculate ideal camera position based on component size
                const bbox = new THREE.Box3().setFromObject(component.mesh);
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Position camera at an offset based on component size
                const offset = new THREE.Vector3(
                    maxDim * 1.5,
                    maxDim * 0.75,
                    maxDim * 1.5
                );
                
                this.targetPosition.copy(component.mesh.position).add(offset);
                this.targetLookAt.copy(component.mesh.position);
                
                // Enable smooth controls during transition
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                this.isTransitioning = true;
                this.startTime = Date.now();
                
                // Return a promise that resolves when the transition is complete
                return new Promise(resolve => {
                    const checkCompletion = () => {
                        if (!this.isTransitioning) resolve();
                        else setTimeout(checkCompletion, 10);
                    };
                    checkCompletion();
                });
            }

            update() {
                if (!this.isTransitioning) return;

                const elapsed = Date.now() - this.startTime;
                const progress = Math.min(elapsed / this.transitionDuration, 1);
                const t = utils.easeInOutCubic(progress);
                
                // Smoothly interpolate camera position
                this.camera.position.lerp(this.targetPosition, t * 0.1);
                
                // Update controls target with smooth interpolation
                this.controls.target.lerp(this.targetLookAt, t * 0.1);
                
                // Restore original control settings when transition completes
                if (progress >= 1) {
                    this.controls.enableDamping = this.originalDamping.enableDamping;
                    this.controls.dampingFactor = this.originalDamping.dampingFactor;
                    this.isTransitioning = false;
                }
            }
        }
        
        const cameraTracker = new CameraTracker(camera, controls);
        
        // Component focus system
        const focusSystem = {
            async focusComponent(component) {
                if (!component || !component.mesh) return;
                return cameraTracker.focusComponent(component);
            }
        };

        // Add sequence focus capability
        const focusSequence = {
            async start(fromComponent, toComponent) {
                if (!fromComponent || !toComponent) return;
                // Let the particle flow handle the camera transitions
                // Don't focus here as it may conflict with the flow animation
                return;
            }
        };

        // Helper function to clear all highlights
        const clearAllHighlights = () => {
            Object.values(components).forEach(component => {
                if (component && component.mesh) {
                    component.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                }
            });
        };

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Text sprite creation helper
        function createTextSprite(text, position, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.font = '24px Arial';
            context.fillStyle = '#333333';
            context.textAlign = 'center';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(scale * 4, scale * 2, 1);
            return sprite;
        }

        // Enhanced Materials with environment mapping
        const envMap = new THREE.CubeTextureLoader()
            .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
            .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);

        const createMetalMaterial = (color, roughness = 0.2) => {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.9,
                roughness: roughness,
                envMap: envMap,
                envMapIntensity: 1
            });
        };

        // Components
        class Component {
            constructor(createGeometryFn, position, name, color) {
                const group = createGeometryFn(color);
                this.mesh = group;
                this.mesh.position.copy(position);
                this.name = name;
                this.mesh.userData.component = this;

                // Add component reference to all child meshes
                this.mesh.traverse((child) => {
                    child.userData.rootComponent = this;
                });
                scene.add(this.mesh);

                // Add component label
                const labelPos = position.clone();
                labelPos.y += 3;
                this.label = createTextSprite(name, labelPos);
                scene.add(this.label);
            }

            highlight(permanent = false, color = 0x00ff00) {
                const highlightColor = new THREE.Color(color);
                this.mesh.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        if (!permanent) {
                            const originalColor = child.material.emissive.clone();
                            child.material.emissive = highlightColor;
                            setTimeout(() => {
                                child.material.emissive = originalColor;
                            }, 1000);
                        } else {
                            child.material.emissive = highlightColor;
                        }
                    }
                });
            }
        }

        // Local Git - Node-based commit graph
        const createLocalGit = (color) => {
            const group = new THREE.Group();
            
            // Create commit nodes
            const commitPoints = [
                new THREE.Vector3(0, 1, 0),      // Main branch tip
                new THREE.Vector3(0, 0, 0),      // Main branch middle
                new THREE.Vector3(0, -1, 0),     // Main branch base
                new THREE.Vector3(1, 0.5, 0),    // Feature branch tip
                new THREE.Vector3(0.5, 0, 0),    // Feature branch base
                new THREE.Vector3(-1, 0.5, 0),   // Hotfix branch tip
                new THREE.Vector3(-0.5, 0, 0),   // Hotfix branch base
            ];

            // Create commit spheres
            const commitGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const commits = commitPoints.map(point => {
                const commit = new THREE.Mesh(
                    commitGeometry,
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                commit.position.copy(point);
                group.add(commit);
                return commit;
            });

            // Create branch connections using tubes
            const connections = [
                [0, 1],  // Main branch top
                [1, 2],  // Main branch bottom
                [3, 4],  // Feature branch
                [4, 1],  // Feature branch connection
                [5, 6],  // Hotfix branch
                [6, 1],  // Hotfix branch connection
            ];

            connections.forEach(([from, to]) => {
                const curve = new THREE.CatmullRomCurve3([
                    commitPoints[from],
                    commitPoints[to]
                ]);

                const tubeGeometry = new THREE.TubeGeometry(
                    curve,
                    8,    // tubular segments
                    0.05, // radius
                    8,    // radial segments
                    false // closed
                );

                const tube = new THREE.Mesh(
                    tubeGeometry,
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                group.add(tube);
            });

            // Add pulsing animation
            let pulseTime = 0;
            group.userData.update = () => {
                pulseTime += 0.02;
                commits.forEach((commit, index) => {
                    const offset = index * 0.5;
                    commit.material.emissiveIntensity = 
                        0.2 + Math.sin(pulseTime + offset) * 0.15;
                    commit.scale.setScalar(
                        1.0 + Math.sin(pulseTime + offset) * 0.05
                    );
                });
            };

            return group;
        };

        // GitHub - Octocat-inspired shape
        const createGitHub = (color) => {
            const group = new THREE.Group();

            // Create octagon platform (GitHub logo inspired)
            const octagonPoints = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                octagonPoints.push(new THREE.Vector2(
                    Math.cos(angle) * 1.5,
                    Math.sin(angle) * 1.5
                ));
            }
            const octagonShape = new THREE.Shape(octagonPoints);
            const octagonGeometry = new THREE.ExtrudeGeometry(octagonShape, {
                depth: 0.4,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 3
            });
            
            const platform = new THREE.Mesh(
                octagonGeometry,
                new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                })
            );
            platform.rotation.x = -Math.PI / 2;
            group.add(platform);

            // Add repository columns
            const columns = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const column = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 2, 8),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        metalness: 0.7,
                        roughness: 0.3
                    })
                );
                column.position.set(
                    Math.cos(angle) * 1.2,
                    1,
                    Math.sin(angle) * 1.2
                );
                columns.push(column);
                group.add(column);
            }

            // Add floating code fragments
            const fragments = [];
            const fragmentCount = 12;
            for (let i = 0; i < fragmentCount; i++) {
                const fragment = new THREE.Group();
                
                // Code block base
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.2, 0.3),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                // Add "code lines"
                const lines = new THREE.Group();
                for (let j = 0; j < 3; j++) {
                    const line = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.03, 0.02),
                        new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            emissive: 0xffffff,
                            emissiveIntensity: 0.5
                        })
                    );
                    line.position.y = 0.05;
                    line.position.z = -0.1 + j * 0.1;
                    lines.add(line);
                }
                
                fragment.add(block);
                fragment.add(lines);
                fragment.userData.angle = (i / fragmentCount) * Math.PI * 2;
                fragment.userData.height = Math.random() * 2;
                fragment.userData.radius = 0.8 + Math.random() * 0.4;
                fragment.userData.speed = 0.02 + Math.random() * 0.01;
                fragments.push(fragment);
                group.add(fragment);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Rotate platform slowly
                platform.rotation.z = time * 0.1;

                // Animate columns
                columns.forEach((column, i) => {
                    column.scale.y = 1 + Math.sin(time * 2 + i) * 0.1;
                });

                // Animate code fragments
                fragments.forEach(fragment => {
                    fragment.userData.angle += fragment.userData.speed;
                    fragment.position.set(
                        Math.cos(fragment.userData.angle) * fragment.userData.radius,
                        fragment.userData.height + Math.sin(time * 2) * 0.2,
                        Math.sin(fragment.userData.angle) * fragment.userData.radius
                    );
                    fragment.rotation.y = -fragment.userData.angle + Math.PI / 2;
                });
            };

            return group;
        };

        // Build Server - Server rack with glowing components
        const createBuildServer = (color) => {
            const group = new THREE.Group();

            // Create main platform
            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 4),
                new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                })
            );
            group.add(platform);

            // Create conveyor belt segments
            const segments = [];
            const segmentCount = 8;
            for (let i = 0; i < segmentCount; i++) {
                const segment = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 0.3),
                    new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.3
                    })
                );
                segment.position.z = -1.5 + (i * 0.4);
                segments.push(segment);
                group.add(segment);
            }

            // Add side rails
            const railGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
            const railMaterial = new THREE.MeshPhongMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2
            });

            const leftRail = new THREE.Mesh(railGeometry, railMaterial);
            leftRail.position.x = -1.2;
            leftRail.position.y = 0.2;
            leftRail.rotation.x = Math.PI / 2;
            group.add(leftRail);

            const rightRail = new THREE.Mesh(railGeometry, railMaterial);
            rightRail.position.x = 1.2;
            rightRail.position.y = 0.2;
            rightRail.rotation.x = Math.PI / 2;
            group.add(rightRail);

            // Add processing stations
            const stations = [];
            const stationCount = 3;
            for (let i = 0; i < stationCount; i++) {
                const station = new THREE.Group();

                // Station base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 1.2, 0.4),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        metalness: 0.6,
                        roughness: 0.4
                    })
                );
                base.position.y = 0.6;
                base.position.x = -1.5;
                base.position.z = -1 + (i * 1.5);
                
                // Processing arm
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.2, 0.2),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        metalness: 0.7,
                        roughness: 0.3
                    })
                );
                arm.position.x = 0.6;
                arm.position.y = 1;
                
                // Tool head
                const tool = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 0.3, 8),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                tool.rotation.x = Math.PI / 2;
                tool.position.y = -0.2;
                
                arm.add(tool);
                base.add(arm);
                station.add(base);
                stations.push(station);
                group.add(station);
            }

            // Add status indicators
            const indicators = [];
            for (let i = 0; i < stationCount; i++) {
                const indicator = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    })
                );
                indicator.position.set(-1.5, 1.3, -1 + (i * 1.5));
                indicators.push(indicator);
                group.add(indicator);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Animate conveyor segments
                segments.forEach((segment, i) => {
                    segment.position.z = -1.5 + ((time + i * 0.4) % 3.2);
                });

                // Animate processing stations
                stations.forEach((station, i) => {
                    const arm = station.children[0].children[0];
                    arm.rotation.z = Math.sin(time * 2 + i) * 0.2;
                });

                // Animate status indicators
                indicators.forEach((indicator, i) => {
                    indicator.material.emissiveIntensity = 
                        0.5 + Math.sin(time * 3 + i * 2) * 0.3;
                });
            };

            return group;
        };

        // Create Test Environment - Virtual Testing Lab
        const createTestEnv = (color) => {
            const group = new THREE.Group();

            // Create main testing chamber (hexagonal)
            const chamberGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1.2, 6);
            const chamber = new THREE.Mesh(
                chamberGeometry,
                new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7,
                    emissive: color,
                    emissiveIntensity: 0.2
                })
            );
            chamber.rotation.x = Math.PI / 2;
            group.add(chamber);

            // Add test pods around the chamber
            const pods = [];
            const podCount = 6;
            for (let i = 0; i < podCount; i++) {
                const pod = new THREE.Group();
                
                // Pod base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.4, 0.4),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        metalness: 0.7,
                        roughness: 0.3
                    })
                );
                
                // Pod scanner
                const scanner = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                scanner.rotation.x = Math.PI / 2;
                scanner.position.z = 0.3;
                
                pod.add(base);
                pod.add(scanner);
                
                const angle = (i / podCount) * Math.PI * 2;
                pod.position.set(
                    Math.cos(angle) * 2,
                    0,
                    Math.sin(angle) * 2
                );
                pod.rotation.y = -angle + Math.PI / 2;
                
                pods.push(pod);
                group.add(pod);
            }

            // Add scanning beams
            const beams = [];
            for (let i = 0; i < podCount; i++) {
                const beam = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 2, 8),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                beam.rotation.x = Math.PI / 2;
                beam.rotation.z = (i / podCount) * Math.PI * 2;
                beams.push(beam);
                group.add(beam);
            }

            // Add holographic test results
            const results = [];
            for (let i = 0; i < 3; i++) {
                const result = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.4, 0.1),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        side: THREE.DoubleSide
                    })
                );
                result.position.y = 0.8 - (i * 0.15);
                results.push(result);
                group.add(result);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Rotate chamber slowly
                chamber.rotation.z = time * 0.1;

                // Animate pods
                pods.forEach((pod, i) => {
                    pod.position.y = Math.sin(time * 2 + i) * 0.1;
                    const scanner = pod.children[1];
                    scanner.rotation.z = Math.sin(time * 3 + i) * 0.2;
                });

                // Animate beams
                beams.forEach((beam, i) => {
                    beam.material.opacity = 0.3 + Math.sin(time * 3 + i) * 0.2;
                    beam.scale.y = 0.8 + Math.sin(time * 2 + i) * 0.2;
                });

                // Animate results
                results.forEach((result, i) => {
                    result.material.opacity = 0.5 + Math.sin(time * 2 + i) * 0.2;
                    result.rotation.y = time;
                });
            };
            return group;
        };

        // Production Environment - Cloud Data Center
        const createProduction = (color) => {
            const group = new THREE.Group();

            // Create main platform
            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 3),
                new THREE.MeshPhongMaterial({
                    color: color,
                    metalness: 0.7,
                    roughness: 0.3
                })
            );
            group.add(platform);

            // Create server racks
            const racks = [];
            const rackRows = 2;
            const racksPerRow = 3;
            
            for (let row = 0; row < rackRows; row++) {
                for (let col = 0; col < racksPerRow; col++) {
                    const rack = new THREE.Group();
                    
                    // Rack frame
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 1.5, 0.6),
                        new THREE.MeshPhongMaterial({
                            color: color,
                            metalness: 0.8,
                            roughness: 0.2
                        })
                    );
                    
                    // Add server units
                    const unitCount = 5;
                    const units = [];
                    for (let i = 0; i < unitCount; i++) {
                        const unit = new THREE.Mesh(
                            new THREE.BoxGeometry(0.7, 0.2, 0.5),
                            new THREE.MeshPhongMaterial({
                                color: color,
                                emissive: color,
                                emissiveIntensity: 0.3
                            })
                        );
                        unit.position.y = -0.6 + (i * 0.25);
                        units.push(unit);
                        rack.add(unit);
                    }
                    
                    rack.add(frame);
                    rack.position.set(
                        -1.5 + col * 1.5,
                        0.85,
                        -0.8 + row * 1.6
                    );
                    racks.push({ frame: rack, units: units });
                    group.add(rack);
                }
            }

            // Add network connections
            const connections = [];
            for (let i = 0; i < racks.length - 1; i++) {
                const start = racks[i].frame.position;
                const end = racks[i + 1].frame.position;
                
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(start.x, start.y + 0.8, start.z),
                    new THREE.Vector3(
                        (start.x + end.x) / 2,
                        start.y + 1,
                        (start.z + end.z) / 2
                    ),
                    new THREE.Vector3(end.x, end.y + 0.8, end.z)
                ]);

                const tubeGeometry = new THREE.TubeGeometry(
                    curve,
                    8,    // tubular segments
                    0.03, // radius
                    8,    // radial segments
                    false // closed
                );

                const connection = new THREE.Mesh(
                    tubeGeometry,
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3,
                        emissive: color,
                        emissiveIntensity: 0.3
                    })
                );
                connections.push(connection);
                group.add(connection);
            }

            // Add floating status indicators
            const indicators = [];
            for (let i = 0; i < 4; i++) {
                const indicator = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.08),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.7,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        side: THREE.DoubleSide
                    })
                );
                indicator.position.set(
                    -1.5 + i * 1,
                    2,
                    0
                );
                indicators.push(indicator);
                group.add(indicator);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Animate server units
                racks.forEach((rack, i) => {
                    rack.units.forEach((unit, j) => {
                        unit.material.emissiveIntensity = 
                            0.3 + Math.sin(time * 2 + i + j) * 0.2;
                    });
                });

                // Animate network connections
                connections.forEach((connection, i) => {
                    connection.material.opacity = 
                        0.3 + Math.sin(time * 3 + i) * 0.1;
                    connection.material.emissiveIntensity = 
                        0.3 + Math.sin(time * 2 + i) * 0.2;
                });

                // Animate status indicators
                indicators.forEach((indicator, i) => {
                    indicator.position.y = 
                        2 + Math.sin(time * 1.5 + i) * 0.1;
                    indicator.material.opacity = 
                        0.7 + Math.sin(time * 2 + i) * 0.2;
                });
            };

            return group;
        };

        // Create GitHub Actions component - Hexagonal Pipeline Processor
        const createGitHubActions = (color) => {
            const group = new THREE.Group();

            // Central hexagonal platform
            const platform = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 0.2, 6),
                new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                })
            );
            platform.rotation.x = Math.PI / 2;
            group.add(platform);

            // Progress bars for each stage
            const stages = ['lint', 'test', 'build'];
            const progressBars = stages.map((stage, index) => {
                const bar = new THREE.Group();
                
                // Bar background
                const background = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.15, 0.1),
                    new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                
                // Progress indicator
                const progress = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.15, 0.1),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                progress.scale.x = 0;
                progress.position.x = -0.4; // Start from left
                
                bar.add(background);
                bar.add(progress);
                
                // Position the bar
                const angle = (index / stages.length) * Math.PI * 2;
                bar.position.set(
                    Math.cos(angle) * 1.8,
                    Math.sin(angle) * 1.8,
                    0.2
                );
                bar.rotation.z = angle + Math.PI / 2;
                
                group.add(bar);
                return { bar, progress };
            });

            // Add rotating gears
            const gearCount = 6;
            const gears = [];
            for (let i = 0; i < gearCount; i++) {
                const gear = new THREE.Group();
                
                // Main gear body
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3
                    })
                );
                
                // Gear teeth
                const teethCount = 8;
                for (let j = 0; j < teethCount; j++) {
                    const tooth = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.1, 0.1),
                        body.material
                    );
                    const angle = (j / teethCount) * Math.PI * 2;
                    tooth.position.set(
                        Math.cos(angle) * 0.35,
                        Math.sin(angle) * 0.35,
                        0
                    );
                    gear.add(tooth);
                }
                
                gear.add(body);
                gear.rotation.x = Math.PI / 2;
                
                const angle = (i / gearCount) * Math.PI * 2;
                gear.position.set(
                    Math.cos(angle) * 2.5,
                    Math.sin(angle) * 2.5,
                    0
                );
                
                group.add(gear);
                gears.push(gear);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Rotate gears
                gears.forEach((gear, i) => {
                    gear.rotation.z = time * (i % 2 === 0 ? 1 : -1);
                });

                // Pulse platform
                platform.material.emissiveIntensity = 0.3 + Math.sin(time * 2) * 0.1;

                // Animate progress bars
                progressBars.forEach(({ progress }, i) => {
                    const phase = (time + i * 0.5) % 3;
                    if (phase < 1) {
                        progress.scale.x = phase;
                        progress.position.x = -0.4 + phase * 0.4;
                    } else if (phase < 2) {
                        progress.scale.x = 1;
                        progress.position.x = 0;
                    } else {
                        progress.scale.x = 1 - (phase - 2);
                        progress.position.x = (phase - 2) * 0.4 - 0.4;
                    }
                });
            };

            return group;
        };

        // Create Pull Request component - Merging Code Streams
        const createPullRequest = (color) => {
            const group = new THREE.Group();

            // Create merge portal (ring)
            const portalRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.8, 0.1, 16, 32),
                new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                })
            );
            portalRing.rotation.x = Math.PI / 2;
            group.add(portalRing);

            // Create particle systems for code streams
            const createStream = (startPos, endPos) => {
                const particleCount = 30;
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = startPos.x + (Math.random() - 0.5) * 0.2;
                    positions[i * 3 + 1] = startPos.y + (Math.random() - 0.5) * 0.2;
                    positions[i * 3 + 2] = startPos.z + (Math.random() - 0.5) * 0.2;
                    
                    const direction = endPos.clone().sub(startPos).normalize();
                    velocities[i * 3] = direction.x * 0.05;
                    velocities[i * 3 + 1] = direction.y * 0.05;
                    velocities[i * 3 + 2] = direction.z * 0.05;
                }

                const particles = new THREE.Points(
                    new THREE.BufferGeometry(),
                    new THREE.PointsMaterial({
                        color: color,
                        size: 0.05,
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending
                    })
                );
                
                particles.geometry.setAttribute('position', 
                    new THREE.Float32BufferAttribute(positions, 3));
                particles.userData.velocities = velocities;
                particles.userData.startPos = startPos;
                particles.userData.endPos = endPos;
                
                return particles;
            };

            // Create two merging streams
            const stream1 = createStream(
                new THREE.Vector3(-1.5, 1, 0),  // Start top-left
                new THREE.Vector3(0, 0, 0)      // Merge center
            );
            const stream2 = createStream(
                new THREE.Vector3(1.5, 1, 0),   // Start top-right
                new THREE.Vector3(0, 0, 0)      // Merge center
            );
            
            group.add(stream1);
            group.add(stream2);

            // Add diff visualization planes
            const diffPlanes = [];
            for (let i = 0; i < 3; i++) {
                const plane = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.2, 0.2),
                    new THREE.MeshPhongMaterial({
                        color: i % 2 === 0 ? 0x4CAF50 : 0xFF5252,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.DoubleSide
                    })
                );
                plane.position.set(0, -0.8 - i * 0.3, 0);
                plane.rotation.x = Math.PI / 6;
                group.add(plane);
                diffPlanes.push(plane);
            }

            // Add animation update function
            let time = 0;
            group.userData.update = () => {
                time += 0.02;

                // Animate portal ring
                portalRing.rotation.z = time;
                portalRing.material.emissiveIntensity = 0.5 + Math.sin(time * 2) * 0.2;

                // Animate particle streams
                [stream1, stream2].forEach(stream => {
                    const positions = stream.geometry.attributes.position.array;
                    const velocities = stream.userData.velocities;
                    
                    for (let i = 0; i < positions.length / 3; i++) {
                        positions[i * 3] += velocities[i * 3];
                        positions[i * 3 + 1] += velocities[i * 3 + 1];
                        positions[i * 3 + 2] += velocities[i * 3 + 2];
                        
                        // Reset particle if it reaches the center
                        const dist = Math.sqrt(
                            positions[i * 3] * positions[i * 3] +
                            positions[i * 3 + 1] * positions[i * 3 + 1]
                        );
                        
                        if (dist < 0.2) {
                            const startPos = stream.userData.startPos;
                            positions[i * 3] = startPos.x + (Math.random() - 0.5) * 0.2;
                            positions[i * 3 + 1] = startPos.y + (Math.random() - 0.5) * 0.2;
                            positions[i * 3 + 2] = startPos.z + (Math.random() - 0.5) * 0.2;
                        }
                    }
                    
                    stream.geometry.attributes.position.needsUpdate = true;
                });

                // Animate diff planes
                diffPlanes.forEach((plane, i) => {
                    plane.material.opacity = 0.5 + Math.sin(time * 2 + i) * 0.2;
                });
            };

            return group;
        };

        // Build Server Status Display
        const createBuildStatus = (text, position, color) => {
            const label = createTextSprite(text, position);
            label.visible = false;
            scene.add(label);
            return label;
        };

        // Create developer component - Code Terminal Matrix
        const createDeveloper = (color) => {
            const group = new THREE.Group();

            // Terminal screen
            const screen = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 0.1),
                new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: color,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                })
            );
            group.add(screen);

            // Add flowing code text planes
            const textPlaneCount = 5;
            for (let i = 0; i < textPlaneCount; i++) {
                const plane = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.8, 0.3),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    })
                );
                plane.position.z = 0.1;
                plane.position.y = 0.8 - (i * 0.4);
                group.add(plane);

                // Add animation data
                plane.userData.speed = 0.02 + Math.random() * 0.02;
                plane.userData.offset = Math.random() * Math.PI * 2;
            }

            // Keyboard base
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 1),
                createMetalMaterial(color)
            );
            keyboard.position.y = -1.5;
            keyboard.position.z = 0.5;
            group.add(keyboard);

            // Add particle emitter for keystrokes
            const particleSystem = new THREE.Points(
                new THREE.BufferGeometry(),
                new THREE.PointsMaterial({
                    color: color,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                })
            );
            
            // Initialize particles
            const particleCount = 20;
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2.8;  // x
                positions[i * 3 + 1] = -1.4;  // y (just above keyboard)
                positions[i * 3 + 2] = 0.5;   // z
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.02;  // x velocity
                velocities[i * 3 + 1] = Math.random() * 0.05;      // y velocity
                velocities[i * 3 + 2] = 0;                         // z velocity
            }
            
            particleSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleSystem.userData.velocities = velocities;
            group.add(particleSystem);

            // Add update function for animations
            group.userData.update = () => {
                // Animate code planes
                group.children.forEach(child => {
                    if (child.geometry instanceof THREE.PlaneGeometry) {
                        child.material.opacity = 0.3 + Math.sin(Date.now() * child.userData.speed + child.userData.offset) * 0.2;
                    }
                });

                // Animate particles
                const positions = particleSystem.geometry.attributes.position.array;
                const velocities = particleSystem.userData.velocities;
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i * 3];     // Update x
                    positions[i * 3 + 1] += velocities[i * 3 + 1]; // Update y
                    
                    // Reset particle if it goes too high
                    if (positions[i * 3 + 1] > -0.5) {
                        positions[i * 3] = (Math.random() - 0.5) * 2.8;
                        positions[i * 3 + 1] = -1.4;
                        velocities[i * 3] = (Math.random() - 0.5) * 0.02;
                        velocities[i * 3 + 1] = Math.random() * 0.05;
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
            };

            return group;
        };

        // Create components with new layout
        const components = {
            developer: new Component(
                createDeveloper,
                new THREE.Vector3(-24, 0, 0),
                'Developer',
                0x9C27B0
            ),
            local: new Component(
                createLocalGit,
                new THREE.Vector3(-16, 0, 0),
                'Local Git',
                0x4CAF50
            ),
            github: new Component(
                createGitHub,
                new THREE.Vector3(-8, 0, 0),
                'GitHub',
                0x2196F3
            ),
            githubActions: new Component(
                createGitHubActions,
                new THREE.Vector3(-8, 0, -6),
                'GitHub Actions',
                0xFFC107
            ),
            buildServer: new Component(
                createBuildServer,
                new THREE.Vector3(-8, -8, 0),
                'Build Server',
                0xFF9800
            ),
            test: new Component(
                createTestEnv,
                new THREE.Vector3(8, 0, 0),
                'Test Env',
                0x9C27B0
            ),
            prod: new Component(
                createProduction,
                new THREE.Vector3(16, 0, 0),
                'Production',
                0xF44336
            )
        };

        // Build Step visualization
        class BuildStep extends AnimatedEntity {
            constructor(name, position, color) {
                super();
                this.name = name;
                this.position = position;
                this.color = color;
                this.progress = 0;
                this.isComplete = false;
                this.isSuccess = false;

                // Create the step visualization
                const geometry = new THREE.BoxGeometry(2, 0.5, 0.5);
                const material = new THREE.MeshPhongMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.5,
                    emissive: this.color,
                    emissiveIntensity: 0.2
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);

                // Create progress indicator (starts invisible)
                const progressGeometry = new THREE.BoxGeometry(0.1, 0.7, 0.7);
                const progressMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                });
                this.progressMesh = new THREE.Mesh(progressGeometry, progressMaterial);
                this.progressMesh.position.copy(position);
                this.progressMesh.position.x -= 1; // Start from the left
                this.progressMesh.visible = false;
                scene.add(this.progressMesh);

                // Create label
                this.label = createTextSprite(name, new THREE.Vector3(position.x, position.y + 0.5, position.z));
                scene.add(this.label);
            }

            async run(shouldSucceed = true) {
                this.isRunning = true;
                this.progress = 0;
                this.progressMesh.visible = true;
                this.mesh.material.opacity = 0.8;

                // Start pulsing effect
                this.startPulse(this.mesh, this.mesh.material.emissiveIntensity);

                // Convert config phases to animation phases
                const phases = CONFIG.animations.buildStep.phases.map((phase, index, arr) => ({
                    duration: phase.duration,
                    start: index === 0 ? 0 : arr[index - 1].progress,
                    end: phase.progress
                }));

                // Animate through phases
                await this.animateWithPhases(phases, (progress) => {
                    this.progress = progress;
                    this.progressMesh.position.x = this.position.x - 1 + (progress * 2);
                });

                this.isRunning = false;
                this.stopPulseEffect();
                this.complete(shouldSucceed);
            }

            complete(success) {
                this.isComplete = true;
                this.isSuccess = success;
                this.isRunning = false;
                this.progressMesh.visible = false;

                // Update appearance based on result
                const resultColor = success ? CONFIG.colors.success : CONFIG.colors.error;
                this.mesh.material.color.setHex(resultColor);
                this.mesh.material.emissive.setHex(resultColor);
                this.label.material.map.dispose();
                this.label = createTextSprite(
                    `${this.name} ${success ? '' : ''}`,
                    new THREE.Vector3(this.position.x, this.position.y + 0.5, this.position.z)
                );
            }

            reset() {
                this.progress = 0;
                this.isRunning = false;
                this.isComplete = false;
                this.isSuccess = false;
                this.progressMesh.visible = false;
                this.mesh.material.color.setHex(this.color);
                this.mesh.material.emissive.setHex(this.color);
                this.mesh.material.opacity = 0.5;
                this.stopPulseEffect();
                this.label.material.map.dispose();
                this.label = createTextSprite(
                    this.name,
                    new THREE.Vector3(this.position.x, this.position.y + 0.5, this.position.z)
                );
            }
        }

        // Create build steps
        const buildSteps = {
            lint: new BuildStep('Linting', new THREE.Vector3(-10, -6, 0), 0xFFEB3B),
            test: new BuildStep('Testing', new THREE.Vector3(-8, -6, 0), 0x4CAF50),
            build: new BuildStep('Building', new THREE.Vector3(-6, -6, 0), 0x2196F3)
        };

        let activePR = null;

        // Create connection lines and action labels
        const connectionMaterials = {
            inactive: new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 }),  // Light gray for inactive
            active: new THREE.LineBasicMaterial({ color: 0x4CAF50, linewidth: 2 })     // Softer green for active
        };
        const connections = [];
        const actionLabels = [];

        function createConnection(start, end, actionText) {
            // Create connection line
            const points = [];
            points.push(start.mesh.position);
            points.push(end.mesh.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, connectionMaterials.inactive);
            line.userData.originalColor = connectionMaterials.inactive;
            scene.add(line);
            connections.push(line);

            // Create action label
            const midPoint = new THREE.Vector3().lerpVectors(start.mesh.position, end.mesh.position, 0.5);
            midPoint.y += 1;
            const actionLabel = createTextSprite(actionText, midPoint, 0.7);
            scene.add(actionLabel);
            actionLabels.push(actionLabel);

            return line;
        }

        // Create connections between components with action labels
        const pathConnections = {
            devToLocal: createConnection(components.developer, components.local, 'code'),
            gitPush: createConnection(components.local, components.github, 'git push'),
            prToActions: createConnection(components.github, components.githubActions, 'PR Trigger'),
            actionsToBuild: createConnection(components.githubActions, components.buildServer, 'CI Jobs'),
            buildToTest: createConnection(components.buildServer, components.test, 'Deploy to Test'),
            testToProd: createConnection(components.test, components.prod, 'Deploy to Prod'),
            buildToDev: createConnection(components.buildServer, components.developer, 'CI Feedback')
        };

        // Function to update path colors
        function updatePathColors(completedPaths) {
            Object.keys(pathConnections).forEach(path => {
                pathConnections[path].material = completedPaths.includes(path) ? 
                    connectionMaterials.active : connectionMaterials.inactive;
            });
        }

        // Particle system for code flow
        class ParticleFlow extends AnimatedEntity {
            constructor(start, end, color = CONFIG.colors.success, isError = false) {
                super();
                this.startPos = typeof start === 'object' && start.mesh ? start.mesh.position : start;
                this.endPos = typeof end === 'object' && end.mesh ? end.mesh.position : end;
                this.isError = isError;
                this.color = color;
                this.particles = [];
                this.progress = 0;
                this.onComplete = null;
                this.createParticles();
            }

            createParticles() {
                const config = this.isError ? CONFIG.animations.flow.errorParticles : CONFIG.animations.flow;
                const particleCount = config.count || CONFIG.animations.flow.particleCount;
                const sizeRange = config.sizeRange || CONFIG.animations.flow.particleSizeRange;
                
                const geometries = [
                    (size) => new THREE.OctahedronGeometry(size),
                    (size) => new THREE.TetrahedronGeometry(size),
                    (size) => new THREE.IcosahedronGeometry(size * 0.8),
                    (size) => {
                        const geometry = new THREE.SphereGeometry(size * 0.7, 8, 8);
                        geometry.scale(1, 0.5, 1); // Create ellipsoid
                        return geometry;
                    }
                ];
                
                for (let i = 0; i < particleCount; i++) {
                    const size = sizeRange.min + Math.random() * (sizeRange.max - sizeRange.min);
                    const geometryFn = geometries[Math.floor(Math.random() * geometries.length)];
                    const geometry = geometryFn(size);
                    
                    const particleColor = (!document.getElementById('lintingCheck').checked || 
                        !document.getElementById('testingCheck').checked || 
                        !document.getElementById('buildingCheck').checked) ? CONFIG.colors.error : this.color;
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: particleColor,
                        transparent: true,
                        opacity: 0.9,
                        emissive: particleColor,
                        emissiveIntensity: 0.7,
                        shininess: 50
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    
                    // Random initial rotation
                    particle.rotation.x = Math.random() * Math.PI * 2;
                    particle.rotation.y = Math.random() * Math.PI * 2;
                    particle.rotation.z = Math.random() * Math.PI * 2;
                    
                    // Add rotation speeds
                    particle.userData.rotationSpeed = {
                        x: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed,
                        y: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed,
                        z: (Math.random() - 0.5) * CONFIG.animations.flow.rotationSpeed
                    };
                    
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        offset: i * (1 / particleCount)  // Evenly spaced particles
                    });
                }
            }

            async startFlow(onComplete, targetComponent) {
                // Clean up and setup
                this.cleanup();
                this.createParticles();
                
                // Get start component based on the flow path
                let startComponent;
                Object.entries(pathConnections).forEach(([path, connection]) => {
                    // Check if this connection starts at our start position
                    if (connection.geometry.attributes.position.array[0] === this.startPos.x &&
                        connection.geometry.attributes.position.array[1] === this.startPos.y &&
                        connection.geometry.attributes.position.array[2] === this.startPos.z) {
                        Object.values(components).forEach(comp => {
                            if (comp.mesh.position.equals(this.startPos)) {
                                startComponent = comp;
                            }
                        });
                    }
                });
                
                // Clear any existing highlights
                clearAllHighlights();
                
                // Store components and initialize state
                this.targetComponent = targetComponent;
                this.startComponent = startComponent;
                this.hasHighlightedTarget = false;
                this.onComplete = onComplete;
                
                // Start the flow immediately
                this.isRunning = true;
                this.progress = 0;
                this.startTime = Date.now();
                this.particles.forEach(p => {
                    p.mesh.visible = true;
                });
                
                // Just highlight the start component
                if (startComponent) {
                    startComponent.highlight();
                }
            }

            stop() {
                this.particles.forEach(p => {
                    p.mesh.visible = false;
                });
                this.stopPulseEffect();
                
                if (this.onComplete) this.onComplete();
                this.isRunning = false;
            }

            update() {
                if (!this.isRunning) return;

                const elapsed = Date.now() - this.startTime;
                const duration = CONFIG.animations.flow.duration;
                this.progress = Math.min(elapsed / duration, 1);


                // At 20%, highlight target component as particles start moving
                if (this.progress >= 0.2 && this.targetComponent && !this.hasHighlightedTarget) {
                    clearAllHighlights();
                    this.targetComponent.highlight();
                    this.hasHighlightedTarget = true;
                }

                // Make sure target stays highlighted at the end
                if (this.progress >= 0.95 && this.targetComponent) {
                    clearAllHighlights();
                    this.targetComponent.highlight();
                }

                this.particles.forEach(particle => {
                    let particleProgress = this.progress - particle.offset;
                    
                    if (particleProgress > 1) {
                        particleProgress = Math.min(particleProgress, 1 + CONFIG.animations.flow.trailLength);
                    } else if (particleProgress < 0) {
                        particleProgress = 0;
                    }
                    
                    // Position with cubic easing
                    const normalizedProgress = Math.min(particleProgress, 1);
                    const easedProgress = utils.easeInOutCubic(normalizedProgress);
                    particle.mesh.position.lerpVectors(
                        this.startPos,
                        this.endPos,
                        easedProgress
                    );

                    // Consistent rotation
                    const rotSpeed = particle.mesh.userData.rotationSpeed;
                    particle.mesh.rotation.x += rotSpeed.x;
                    particle.mesh.rotation.y += rotSpeed.y;
                    particle.mesh.rotation.z += rotSpeed.z;

                    // Quick fade in, gradual fade out
                    let fade = 1.0;
                    if (particleProgress <= CONFIG.animations.flow.fadeInDuration) {
                        fade = particleProgress / CONFIG.animations.flow.fadeInDuration;
                    } else if (particleProgress >= 1.0) {
                        fade = 1.0 - ((particleProgress - 1.0) / CONFIG.animations.flow.trailLength);
                    }
                    
                    fade = utils.easeInOutCubic(fade);
                    particle.mesh.visible = fade > 0;
                    particle.mesh.material.opacity = fade * 0.9;
                    particle.mesh.material.emissiveIntensity = 0.5 + fade * 0.5;
                });

                if (elapsed >= duration) {
                    if (this.onComplete) this.onComplete();
                    this.stop();
                }
            }

            cleanup() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.mesh.material) {
                        p.mesh.material.dispose();
                    }
                    if (p.mesh.geometry) {
                        p.mesh.geometry.dispose();
                    }
                });
                this.particles = [];
                this.isRunning = false;
            }
        }

        // GitHub Actions visualization
        class GitHubActions {
            constructor(position) {
                this.position = position.clone();
                this.position.y += 1;
                this.processes = ['lint', 'test', 'build'];
                this.currentProcess = -1;
                this.processLabels = this.processes.map((process, index) => {
                    const label = createTextSprite(process, 
                        new THREE.Vector3(position.x - 1 + index, position.y + 1, position.z));
                    label.visible = false;
                    scene.add(label);
                    return label;
                });
            }

            async runProcess() {
                this.currentProcess = -1;
                for (let i = 0; i < this.processes.length; i++) {
                    this.currentProcess = i;
                    this.processLabels[i].visible = true;
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} `,
                        this.processLabels[i].position
                    );
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} `,
                        this.processLabels[i].position
                    );
                }
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            reset() {
                this.processLabels.forEach(label => {
                    label.visible = false;
                });
                this.currentProcess = -1;
            }
        }

        // Create particle flows for each path after ParticleFlow class is defined
        const getFlowColor = () => {
            return (!document.getElementById('lintingCheck').checked || 
                    !document.getElementById('testingCheck').checked || 
                    !document.getElementById('buildingCheck').checked) ? CONFIG.colors.error : CONFIG.colors.success;
        };

        const flows = {
            devToLocal: new ParticleFlow(components.developer, components.local, getFlowColor()),
            gitPush: new ParticleFlow(components.local, components.github, getFlowColor()),
            prToActions: new ParticleFlow(components.github, components.githubActions, getFlowColor()),
            actionsToBuild: new ParticleFlow(components.githubActions, components.buildServer, getFlowColor()),
            buildToTest: new ParticleFlow(components.buildServer, components.test, getFlowColor()),
            testToProd: new ParticleFlow(components.test, components.prod, getFlowColor()),
            buildToDev: new ParticleFlow(components.buildServer, components.developer, CONFIG.colors.error),
            deployTest: new ParticleFlow(components.buildServer, components.test, getFlowColor()),
            deployProd: new ParticleFlow(components.test, components.prod, getFlowColor()),
            feedbackToDev: new ParticleFlow(components.buildServer, components.developer, CONFIG.colors.error)
        };

        const githubActions = new GitHubActions(components.github.mesh.position);

        // History log system
        const historySystem = {
            actions: [],
            addAction: function(action) {
                const timestamp = new Date().toLocaleTimeString();
                const actionItem = { timestamp, action, type: pipelineState.currentAction };
                this.actions.push(actionItem);
                this.updateHistoryLog();
            },
            updateHistoryLog: function() {
                const historyLog = document.getElementById('historyLog');
                const actionItem = this.actions[this.actions.length - 1];
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-2 bg-gray-50 rounded border-l-4 border-blue-500 mb-1.5 hover:bg-gray-100 transition-colors duration-200';
                
                const timeSpan = document.createElement('span');
                timeSpan.className = 'text-gray-600 text-sm';
                timeSpan.textContent = actionItem.timestamp;
                
                const actionSpan = document.createElement('div');
                actionSpan.className = 'mt-0.5';
                actionSpan.textContent = actionItem.action;
                
                const replayButton = document.createElement('button');
                replayButton.textContent = 'Replay';
                replayButton.className = 'mt-1.5 px-2 py-1 bg-green-500 hover:bg-green-600 text-white rounded text-xs cursor-pointer transition-colors duration-200';
                replayButton.onclick = () => this.replayAction(actionItem);
                
                itemDiv.appendChild(timeSpan);
                itemDiv.appendChild(actionSpan);
                itemDiv.appendChild(replayButton);
                historyLog.appendChild(itemDiv);
                
                // Scroll to bottom
                historyLog.scrollTop = historyLog.scrollHeight;
            },
            replayAction: async function(actionItem) {
                if (pipelineState.isProcessing) {
                    alert('Please wait for the current action to complete');
                    return;
                }
                
                switch(actionItem.type) {
                    case 'commit':
                        await handleCommit();
                        break;
                    case 'push':
                        if (pipelineState.hasLocalChanges) {
                            pipelineState.currentAction = 'push';
                            components.local.highlight();
                            flows.gitPush.startFlow(() => {
                                showStatus('Code pushed successfully! Click GitHub to create PR');
                                pipelineState.canPush = false;
                                pipelineState.canCreatePR = true;
                                pipelineState.isProcessing = false;
                            });
                        }
                        break;
                    case 'pr':
                        if (pipelineState.canCreatePR) {
                            handlePRCreation();
                        }
                        break;
                }
            }
        };

        // Pipeline Flow Manager
        class FlowManager {
            constructor() {
                this.state = {
                    canPush: true,
                    canCreatePR: false,
                    isProcessing: false,
                    canCommit: true,
                    hasLocalChanges: false,
                    currentAction: null,
                    prFailed: false,
                    codeQuality: {
                        linting: true,
                        testing: true,
                        building: true
                    }
                };
            }

            async executeStep({ 
                status, 
                flow = null, 
                action = null,
                targetComponent = null
            }) {
                showStatus(status);
                
                if (flow) {
                    return new Promise(async (resolve) => {
                        flow.startFlow(() => {
                            resolve();
                        }, targetComponent);
                    });
                }

                if (action) {
                    await action();
                }
            }

            async runPipeline(steps) {
                this.state.isProcessing = true;
                
                try {
                    for (const step of steps) {
                        await this.executeStep(step);
                    }
                    return true;
                } catch (error) {
                    console.error('Pipeline error:', error);
                    showStatus(`Pipeline failed: ${error.message}`);
                    return false;
                } finally {
                    this.state.isProcessing = false;
                }
            }
        }

        // Initialize Flow Manager
        const flowManager = new FlowManager();
        const pipelineState = flowManager.state;



        // Commit button handler
        const handleCommit = async () => {
            if (!pipelineState.canCommit || pipelineState.isProcessing) {
                showStatus('Please wait for the current process to complete...');
                return;
            }

            // Get code quality settings
            pipelineState.codeQuality = {
                linting: document.getElementById('lintingCheck').checked,
                testing: document.getElementById('testingCheck').checked,
                building: document.getElementById('buildingCheck').checked
            };

            pipelineState.currentAction = 'commit';
            updatePathColors(['devToLocal']);

            const qualityStatus = `(Linting: ${pipelineState.codeQuality.linting ? '' : ''}, Testing: ${pipelineState.codeQuality.testing ? '' : ''}, Building: ${pipelineState.codeQuality.building ? '' : ''})`;

            const commitSteps = [
                {
                    status: 'Developer committing changes...',
                    flow: flows.devToLocal,
                    targetComponent: components.local,
                    delayTime: 1500
                },
                {
                    status: `Changes committed to local repository ${qualityStatus}`,
                    action: () => {
                        pipelineState.hasLocalChanges = true;
                        pipelineState.canPush = true;
                    }
                }
            ];

            await flowManager.runPipeline(commitSteps);
        };

        // Handle commit button click
        document.getElementById('commitButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing) {
                handleCommit();
            }
        });

        // Handle push button click
        document.getElementById('pushButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canPush && pipelineState.hasLocalChanges) {
                handleGitPush();
            } else {
                showStatus('Cannot push: Ensure you have committed changes and no process is running');
            }
        });

        // Handle PR button click
        document.getElementById('createPRButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canCreatePR) {
                handlePRCreation();
            } else {
                showStatus('Cannot create PR: Ensure you have pushed changes and no process is running');
            }
        });

        // Build step helper function
        const runBuildStep = async (status, message, duration, isError = false) => {
            return new Promise((resolve, reject) => {
                showStatus(message);
                status.visible = true;
                
                // If this is an error step, create error feedback particles
                if (isError) {
                    const errorFlow = new ParticleFlow(
                        components.gitHubActions.mesh.position,
                        components.developer.mesh.position,
                        CONFIG.colors.error,
                        true
                    );
                    errorFlow.start();
                }

                setTimeout(() => {
                    // 80% chance of success
                    if (Math.random() > 0.2) {
                        status.material.color.setHex(0x4CAF50);
                        resolve();
                    } else {
                        status.material.color.setHex(0xFF5252);
                        reject(new Error('Build step failed'));
                    }
                }, duration);
            });
        };

        // PR Creation Handler
        let simulateFailure = false; // Control whether the pipeline should fail

        const handlePRCreation = async () => {
            if (!pipelineState.canCreatePR) {
                showStatus('Cannot create PR: Waiting for previous process to complete');
                return;
            }
            pipelineState.currentAction = 'pr';
            pipelineState.canCreatePR = false;
            updatePathColors(['prToActions']);

            // Get code quality status
            const codeQuality = {
                linting: document.getElementById('lintingCheck').checked,
                testing: document.getElementById('testingCheck').checked,
                building: document.getElementById('buildingCheck').checked
            };

            // Reset all build steps
            Object.values(buildSteps).forEach(step => step.reset());

            // Create PR visualization
            if (activePR) {
                scene.remove(activePR.mesh);
                scene.remove(activePR.label);
            }
            activePR = new Component(
                createPullRequest,
                new THREE.Vector3(-4, 0, 0),
                'Pull Request',
                0xFFEB3B
            );

            // Initial PR creation and trigger steps
            await flowManager.runPipeline([
                {
                    status: 'Creating Pull Request...',
                    action: () => activePR.highlight(),
                    delayTime: 1000
                },
                {
                    status: 'PR triggering GitHub Actions...',
                    flow: flows.prToActions,
                    targetComponent: components.githubActions,
                    delayTime: 2000
                },
                {
                    status: 'Starting CI Pipeline...',
                    flow: flows.actionsToBuild,
                    targetComponent: components.buildServer,
                    delayTime: 1000
                }
            ]);

            // Run linting step
            await flowManager.runPipeline([
                {
                    status: 'Running linting...',
                    action: () => buildSteps.lint.run(),
                    delayTime: 2000
                }
            ]);
            
            if (!pipelineState.codeQuality.linting) {
                pipelineState.prFailed = true; // Set failed flag for lint failure
                await flowManager.runPipeline([
                    {
                        status: 'Linting failed!  Check code style and formatting.',
                        delayTime: 1000
                    }
                ]);
                await flowManager.runPipeline([
                    {
                        status: 'Sending feedback to developer...',
                        flow: flows.buildToDev,
                        targetComponent: components.developer,
                        delayTime: 2000
                    }
                ]);
                showStatus('Pipeline failed at linting stage - Will retry after next push');
                return;
            }

            await flowManager.runPipeline([{
                status: 'Linting passed ',
                delayTime: 1000
            }]);

            // Run testing step
            await flowManager.runPipeline([{
                status: 'Running tests...',
                action: () => buildSteps.test.run(),
                delayTime: 2000
            }]);
            
            if (!pipelineState.codeQuality.testing) {
                pipelineState.prFailed = true; // Set failed flag for test failure
                await flowManager.runPipeline([
                    {
                        status: 'Tests failed!  Fix failing tests.',
                        delayTime: 1000
                    },
                    {
                        status: 'Sending feedback to developer...',
                        flow: flows.buildToDev,
                        targetComponent: components.developer,
                        delayTime: 2000
                    }
                ]);
                showStatus('Pipeline failed at testing stage - Will retry after next push');
                return;
            }

            await flowManager.runPipeline([{
                status: 'Tests passed ',
                delayTime: 1000
            }]);

            // Run build step
            await flowManager.runPipeline([{
                status: 'Building project...',
                action: () => buildSteps.build.run(),
                delayTime: 2000
            }]);
            
            if (!pipelineState.codeQuality.building) {
                pipelineState.prFailed = true; // Set failed flag for build failure
                await flowManager.runPipeline([
                    {
                        status: 'Build failed!  Fix build errors.',
                        delayTime: 1000
                    }
                ]);
                await flowManager.runPipeline([
                    {
                        status: 'Sending feedback to developer...',
                        flow: flows.buildToDev,
                        targetComponent: components.developer,
                        delayTime: 2000
                    }
                ]);
                showStatus('Pipeline failed at build stage - Will retry after next push');
                return;
            }

            await flowManager.runPipeline([{
                status: 'Build successful ',
                delayTime: 1000
            }]);

            // Run deployment steps if all checks passed
            try {

                // If all steps pass, continue with deployment
                await flowManager.runPipeline([
                    {
                        status: 'Deploying to test environment...',
                        flow: flows.deployTest,
                        targetComponent: components.test,
                        delayTime: 2000
                    },
                    {
                        status: 'Deploying to production...',
                        flow: flows.deployProd,
                        targetComponent: components.prod,
                        delayTime: 2000
                    },
                    {
                        status: 'Pipeline completed successfully!',
                        action: () => {
                            pipelineState.canCommit = true;
                        },
                        delayTime: 500
                    }
                ]);
            } catch (error) {
                console.error('Error in PR creation:', error);
                pipelineState.prFailed = true;
                await flowManager.runPipeline([{
                    status: 'PR Creation failed - will retry after next push...',
                    flow: flows.buildToDev,
                    targetComponent: components.developer,
                    delayTime: 2000
                }]);
                await utils.delay(2000);
                flows.feedbackToDev.stop();
                pipelineState.canCommit = true;
            }
        };

        // Git push handler
        const handleGitPush = async () => {
            pipelineState.currentAction = 'push';
            if (pipelineState.prFailed) {
                showStatus('Previous PR failed - restarting workflow after push...');
                components.github.highlight();
            }
            updatePathColors(['gitPush']);

            const pushSteps = [
                {
                    status: 'Pushing to GitHub...',
                    flow: flows.gitPush,
                    targetComponent: components.github,
                    delayTime: 1500
                },
                {
                    status: 'Changes pushed to GitHub',
                    delayTime: 1000,
                    action: async () => {
                        pipelineState.canPush = false;
                        pipelineState.hasLocalChanges = false;

                        
                        if (pipelineState.prFailed) {
                            showStatus('Push complete. Preparing to restart PR creation...');
                            
                            // Ensure clean state before PR creation
                            pipelineState.isProcessing = false;
                            await utils.delay(100);
                            pipelineState.canCreatePR = true;
                            await utils.delay(100);
                            
                            showStatus('Automatically restarting PR creation...');
                            try {
                                await handlePRCreation();
                                pipelineState.prFailed = false;
                            } catch (error) {
                                console.error('Error auto-triggering PR:', error);
                                showStatus('Failed to auto-trigger PR. Please try manually.');
                            }
                        } else {
                            pipelineState.isProcessing = false;
                            pipelineState.canCreatePR = true;
                        }
                    }
                }
            ];

            await flowManager.runPipeline(pushSteps);
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera tracking
            cameraTracker.update();
            controls.update();

            // Update component animations
            Object.values(components).forEach(component => {
                if (component.mesh && component.mesh.userData.update) {
                    component.mesh.userData.update();
                }
            });

            // Update flows
            Object.values(flows).forEach(flow => {
                if (flow.isRunning) {
                    flow.update();
                }
            });

            // Update labels to face camera
            Object.values(components).forEach(component => {
                component.label.quaternion.copy(camera.quaternion);
            });
            actionLabels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize component selector buttons
        const selectorContainer = document.querySelector('#componentSelector div');
        Object.entries(components).forEach(([key, component]) => {
            const button = document.createElement('button');
            button.className = 'px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded-md text-sm font-medium transition-colors';
            button.textContent = component.name;
            button.onclick = () => {
                // Remove highlight from all components
                Object.values(components).forEach(c => {
                    c.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                });
                
                // Highlight selected component
                component.mesh.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0x444444);
                    }
                });
                
                focusSystem.focusComponent(component);
                animate();
            };
            selectorContainer.appendChild(button);
        });

        animate();
    </script>
</body>
</html>