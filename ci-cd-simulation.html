<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 1.2em;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div id="info">CI/CD Pipeline Simulation<br>Click components to interact</div>
    <div id="status">Ready</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Text sprite creation helper
        function createTextSprite(text, position, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(scale * 4, scale * 2, 1);
            return sprite;
        }

        // Components
        class Component {
            constructor(geometry, material, position, name) {
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.name = name;
                this.mesh.userData.component = this;
                scene.add(this.mesh);

                // Add component label
                const labelPos = position.clone();
                labelPos.y += 2;
                this.label = createTextSprite(name, labelPos);
                scene.add(this.label);
            }

            highlight() {
                this.mesh.material.emissive.setHex(0x00ff00);
                setTimeout(() => {
                    this.mesh.material.emissive.setHex(0x000000);
                }, 1000);
            }
        }

        // Create components
        const components = {
            local: new Component(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x4CAF50 }),
                new THREE.Vector3(-8, 0, 0),
                'Local Git'
            ),
            github: new Component(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x2196F3 }),
                new THREE.Vector3(-4, 0, 0),
                'GitHub'
            ),
            buildServer: new Component(
                new THREE.BoxGeometry(2, 3, 2),
                new THREE.MeshPhongMaterial({ color: 0xFF9800 }),
                new THREE.Vector3(0, 0, 0),
                'Build Server'
            ),
            test: new Component(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x9C27B0 }),
                new THREE.Vector3(4, 0, 0),
                'Test Env'
            ),
            prod: new Component(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0xF44336 }),
                new THREE.Vector3(8, 0, 0),
                'Production'
            )
        };

        // Create connection lines and action labels
        const connectionMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const connections = [];
        const actionLabels = [];

        function createConnection(start, end, actionText) {
            // Create connection line
            const points = [];
            points.push(start.mesh.position);
            points.push(end.mesh.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, connectionMaterial);
            scene.add(line);
            connections.push(line);

            // Create action label
            const midPoint = new THREE.Vector3().lerpVectors(start.mesh.position, end.mesh.position, 0.5);
            midPoint.y += 1;
            const actionLabel = createTextSprite(actionText, midPoint, 0.7);
            scene.add(actionLabel);
            actionLabels.push(actionLabel);
        }

        // Create connections between components with action labels
        createConnection(components.local, components.github, 'git push');
        createConnection(components.github, components.buildServer, 'PR + CI Trigger');
        createConnection(components.buildServer, components.test, 'Deploy to Test');
        createConnection(components.test, components.prod, 'Deploy to Prod');

        // Status message handler
        function showStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
        }

        // Particle system for code flow
        class ParticleFlow {
            constructor(start, end, color = 0x00ff00) {
                this.startPos = start;
                this.endPos = end;
                this.color = color;
                this.particles = [];
                this.progress = 0;
                this.active = false;
                this.onComplete = null;
                this.createParticles();
            }

            createParticles() {
                // Create multiple particles for a trail effect
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new THREE.MeshPhongMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        offset: i * 0.15 // Spread particles along the path
                    });
                }
            }

            startFlow(onComplete) {
                this.active = true;
                this.progress = 0;
                this.particles.forEach(p => p.mesh.visible = true);
                this.onComplete = onComplete;
            }

            update() {
                if (!this.active) return;

                this.progress += 0.005; // Slower animation

                this.particles.forEach(particle => {
                    let particleProgress = this.progress - particle.offset;
                    if (particleProgress < 0) particleProgress = 0;
                    if (particleProgress > 1) particleProgress = 1;

                    particle.mesh.position.lerpVectors(
                        this.startPos,
                        this.endPos,
                        particleProgress
                    );

                    // Fade particles at start and end
                    const fade = 1 - Math.abs(particleProgress - 0.5) * 2;
                    particle.mesh.material.opacity = fade * 0.8;
                });

                if (this.progress >= 1.15) { // Account for trail length
                    this.active = false;
                    this.particles.forEach(p => p.mesh.visible = false);
                    if (this.onComplete) this.onComplete();
                }
            }
        }

        // GitHub Actions visualization
        class GitHubActions {
            constructor(position) {
                this.position = position.clone();
                this.position.y += 1;
                this.processes = ['lint', 'test', 'build'];
                this.currentProcess = -1;
                this.processLabels = this.processes.map((process, index) => {
                    const label = createTextSprite(process, 
                        new THREE.Vector3(position.x - 1 + index, position.y + 1, position.z));
                    label.visible = false;
                    scene.add(label);
                    return label;
                });
            }

            async runProcess() {
                this.currentProcess = -1;
                for (let i = 0; i < this.processes.length; i++) {
                    this.currentProcess = i;
                    this.processLabels[i].visible = true;
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ⏳`,
                        this.processLabels[i].position
                    );
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ✓`,
                        this.processLabels[i].position
                    );
                }
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            reset() {
                this.processLabels.forEach(label => {
                    label.visible = false;
                });
                this.currentProcess = -1;
            }
        }

        // Create flows
        const flows = {
            gitPush: new ParticleFlow(components.local.mesh.position, components.github.mesh.position),
            prTrigger: new ParticleFlow(components.github.mesh.position, components.buildServer.mesh.position, 0xff9800),
            deployTest: new ParticleFlow(components.buildServer.mesh.position, components.test.mesh.position, 0x9C27B0),
            deployProd: new ParticleFlow(components.test.mesh.position, components.prod.mesh.position, 0xF44336)
        };

        const githubActions = new GitHubActions(components.github.mesh.position);

        // Pipeline state
        let pipelineState = {
            canPush: true,
            canCreatePR: false,
            isProcessing: false
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Update flows
            Object.values(flows).forEach(flow => flow.update());

            // Update labels to face camera
            Object.values(components).forEach(component => {
                component.label.quaternion.copy(camera.quaternion);
            });
            actionLabels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle component clicking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0 && !pipelineState.isProcessing) {
                const object = intersects[0].object;
                if (object.userData.component) {
                    const component = object.userData.component;
                    component.highlight();

                    if (component === components.local && pipelineState.canPush) {
                        // Handle git push
                        pipelineState.isProcessing = true;
                        showStatus('Pushing code changes to GitHub...');
                        flows.gitPush.startFlow(() => {
                            showStatus('Code pushed successfully! Click GitHub to create PR');
                            pipelineState.canPush = false;
                            pipelineState.canCreatePR = true;
                            pipelineState.isProcessing = false;
                        });
                    } 
                    else if (component === components.github && pipelineState.canCreatePR) {
                        // Handle PR creation and GitHub Actions
                        pipelineState.isProcessing = true;
                        pipelineState.canCreatePR = false;
                        showStatus('Creating Pull Request...');
                        
                        // Run GitHub Actions
                        githubActions.runProcess().then(() => {
                            showStatus('CI checks passed! Triggering build...');
                            // Trigger build server
                            flows.prTrigger.startFlow(() => {
                                showStatus('Build successful! Deploying to Test...');
                                // Deploy to test
                                flows.deployTest.startFlow(() => {
                                    showStatus('Test deployment successful! Deploying to Production...');
                                    // Deploy to prod
                                    flows.deployProd.startFlow(() => {
                                        // Reset pipeline
                                        showStatus('Deployment complete! Ready for next changes.');
                                        pipelineState.isProcessing = false;
                                        pipelineState.canPush = true;
                                        githubActions.reset();
                                    });
                                });
                            });
                        });
                    }
                }
            }
        });

        animate();
    </script>
</body>
</html>