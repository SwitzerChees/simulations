<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 1.2em;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div id="info">CI/CD Pipeline Simulation<br>Click components to interact</div>
    <div id="status">Ready</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Text sprite creation helper
        function createTextSprite(text, position, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(scale * 4, scale * 2, 1);
            return sprite;
        }

        // Enhanced Materials with environment mapping
        const envMap = new THREE.CubeTextureLoader()
            .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
            .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);

        const createMetalMaterial = (color, roughness = 0.2) => {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.9,
                roughness: roughness,
                envMap: envMap,
                envMapIntensity: 1
            });
        };

        // Components
        class Component {
            constructor(createGeometryFn, position, name, color) {
                const group = createGeometryFn(color);
                this.mesh = group;
                this.mesh.position.copy(position);
                this.name = name;
                this.mesh.userData.component = this;
                // Add component reference to all child meshes
                this.mesh.traverse((child) => {
                    child.userData.rootComponent = this;
                });
                scene.add(this.mesh);

                // Add component label
                const labelPos = position.clone();
                labelPos.y += 3;
                this.label = createTextSprite(name, labelPos);
                scene.add(this.label);
            }

            highlight() {
                const highlightColor = new THREE.Color(0x00ff00);
                const originalColors = new Map();
                this.mesh.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        originalColors.set(child, child.material.emissive.clone());
                        child.material.emissive = highlightColor;
                    }
                });
                setTimeout(() => {
                    originalColors.forEach((color, obj) => {
                        obj.material.emissive = color;
                    });
                }, 1000);
            }
        }

        // Local Git - Repository with branching structure
        const createLocalGit = (color) => {
            const group = new THREE.Group();
            
            // Main cylinder (trunk)
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 3, 8),
                createMetalMaterial(color)
            );
            group.add(trunk);

            // Branches
            for (let i = 0; i < 3; i++) {
                const branch = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 2, 8),
                    createMetalMaterial(color)
                );
                branch.position.y = -0.5 + i;
                branch.rotation.z = Math.PI / 3;
                branch.position.x = 0.8;
                group.add(branch);
            }

            return group;
        };

        // GitHub - Octocat-inspired shape
        const createGitHub = (color) => {
            const group = new THREE.Group();

            // Body (octagon)
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 2, 8),
                createMetalMaterial(color)
            );
            group.add(body);

            // Tentacles
            for (let i = 0; i < 8; i++) {
                const tentacle = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.1, 8, 6),
                    createMetalMaterial(color)
                );
                tentacle.rotation.y = (i / 8) * Math.PI * 2;
                tentacle.position.y = -1;
                group.add(tentacle);
            }

            return group;
        };

        // Build Server - Server rack with glowing components
        const createBuildServer = (color) => {
            const group = new THREE.Group();

            // Main frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(3, 4, 2),
                createMetalMaterial(color, 0.5)
            );
            group.add(frame);

            // Glowing server units
            for (let i = 0; i < 4; i++) {
                const unit = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.5, 1.5),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                unit.position.y = -1.5 + i;
                group.add(unit);
            }

            return group;
        };

        // Test Environment - Molecular structure
        const createTestEnv = (color) => {
            const group = new THREE.Group();

            // Central sphere
            const center = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                createMetalMaterial(color)
            );
            group.add(center);

            // Orbiting test nodes
            for (let i = 0; i < 4; i++) {
                const orbit = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 4) * Math.PI * 2;
                orbit.position.set(
                    Math.cos(angle) * 1.5,
                    Math.sin(angle) * 1.5,
                    0
                );
                group.add(orbit);

                // Connection to center
                const line = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                    createMetalMaterial(color)
                );
                line.position.set(
                    Math.cos(angle) * 0.75,
                    Math.sin(angle) * 0.75,
                    0
                );
                line.lookAt(orbit.position);
                group.add(line);
            }

            return group;
        };

        // Production - Cloud-like structure
        const createProduction = (color) => {
            const group = new THREE.Group();

            // Main cloud shapes
            const shapes = [
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
            ];

            const positions = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-1, 0.2, 0),
                new THREE.Vector3(1, 0.2, 0),
            ];

            shapes.forEach((shape, i) => {
                const cloud = new THREE.Mesh(
                    shape,
                    createMetalMaterial(color)
                );
                cloud.position.copy(positions[i]);
                group.add(cloud);
            });

            // Add some smaller detail spheres
            for (let i = 0; i < 5; i++) {
                const detail = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 5) * Math.PI * 2;
                detail.position.set(
                    Math.cos(angle) * 1.2,
                    Math.sin(angle) * 0.3 + 0.5,
                    0
                );
                group.add(detail);
            }

            return group;
        };

        // Create GitHub Actions component
        const createGitHubActions = (color) => {
            const group = new THREE.Group();

            // Central hexagon
            const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 6);
            const material = createMetalMaterial(color);
            const hexagon = new THREE.Mesh(geometry, material);
            hexagon.rotation.x = Math.PI / 2;
            group.add(hexagon);

            // Orbiting gears
            const gearCount = 6;
            for (let i = 0; i < gearCount; i++) {
                const gearGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
                const gear = new THREE.Mesh(gearGeometry, material);
                const angle = (i / gearCount) * Math.PI * 2;
                gear.position.x = Math.cos(angle) * 2;
                gear.position.z = Math.sin(angle) * 2;
                gear.rotation.x = Math.PI / 2;
                group.add(gear);
            }

            return group;
        };

        // Create Pull Request component
        const createPullRequest = (color) => {
            const group = new THREE.Group();

            // PR document shape
            const document = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2, 0.2),
                createMetalMaterial(color)
            );
            group.add(document);

            // Add lines of "text"
            const textMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.1, 0.1),
                    textMat
                );
                line.position.y = 0.5 - (i * 0.4);
                group.add(line);
            }

            return group;
        };

        // Build Server Status Display
        const createBuildStatus = (text, position, color) => {
            const label = createTextSprite(text, position);
            label.visible = false;
            scene.add(label);
            return label;
        };

        // Create components with new layout
        const components = {
            local: new Component(
                createLocalGit,
                new THREE.Vector3(-16, 0, 0),
                'Local Git',
                0x4CAF50
            ),
            github: new Component(
                createGitHub,
                new THREE.Vector3(-8, 0, 0),
                'GitHub',
                0x2196F3
            ),
            githubActions: new Component(
                createGitHubActions,
                new THREE.Vector3(-8, 6, 0),
                'GitHub Actions',
                0xFFC107
            ),
            buildServer: new Component(
                createBuildServer,
                new THREE.Vector3(-8, -8, 0),
                'Build Server',
                0xFF9800
            ),
            test: new Component(
                createTestEnv,
                new THREE.Vector3(8, 0, 0),
                'Test Env',
                0x9C27B0
            ),
            prod: new Component(
                createProduction,
                new THREE.Vector3(16, 0, 0),
                'Production',
                0xF44336
            )
        };

        // Create build status indicators
        const buildStatuses = {
            lint: createBuildStatus('Linting...', new THREE.Vector3(-10, -6, 0), 0xFFEB3B),
            test: createBuildStatus('Testing...', new THREE.Vector3(-8, -6, 0), 0x4CAF50),
            build: createBuildStatus('Building...', new THREE.Vector3(-6, -6, 0), 0x2196F3)
        };

        let activePR = null;

        // Create connection lines and action labels
        const connectionMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const connections = [];
        const actionLabels = [];

        function createConnection(start, end, actionText) {
            // Create connection line
            const points = [];
            points.push(start.mesh.position);
            points.push(end.mesh.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, connectionMaterial);
            scene.add(line);
            connections.push(line);

            // Create action label
            const midPoint = new THREE.Vector3().lerpVectors(start.mesh.position, end.mesh.position, 0.5);
            midPoint.y += 1;
            const actionLabel = createTextSprite(actionText, midPoint, 0.7);
            scene.add(actionLabel);
            actionLabels.push(actionLabel);
        }

        // Create connections between components with action labels
        createConnection(components.local, components.github, 'git push');
        createConnection(components.github, components.buildServer, 'PR + CI Trigger');
        createConnection(components.buildServer, components.test, 'Deploy to Test');
        createConnection(components.test, components.prod, 'Deploy to Prod');

        // Status message handler
        function showStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
        }

        // Particle system for code flow
        class ParticleFlow {
            constructor(start, end, color = 0x00ff00) {
                this.startPos = start;
                this.endPos = end;
                this.color = color;
                this.particles = [];
                this.progress = 0;
                this.active = false;
                this.onComplete = null;
                this.createParticles();
            }

            createParticles() {
                // Create multiple particles for a trail effect
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new THREE.MeshPhongMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        offset: i * 0.15 // Spread particles along the path
                    });
                }
            }

            startFlow(onComplete) {
                this.active = true;
                this.progress = 0;
                this.particles.forEach(p => p.mesh.visible = true);
                this.onComplete = onComplete;
            }

            update() {
                if (!this.active) return;

                this.progress += 0.005; // Slower animation

                this.particles.forEach(particle => {
                    let particleProgress = this.progress - particle.offset;
                    if (particleProgress < 0) particleProgress = 0;
                    if (particleProgress > 1) particleProgress = 1;

                    particle.mesh.position.lerpVectors(
                        this.startPos,
                        this.endPos,
                        particleProgress
                    );

                    // Fade particles at start and end
                    const fade = 1 - Math.abs(particleProgress - 0.5) * 2;
                    particle.mesh.material.opacity = fade * 0.8;
                });

                if (this.progress >= 1.15) { // Account for trail length
                    this.active = false;
                    this.particles.forEach(p => p.mesh.visible = false);
                    if (this.onComplete) this.onComplete();
                }
            }
        }

        // GitHub Actions visualization
        class GitHubActions {
            constructor(position) {
                this.position = position.clone();
                this.position.y += 1;
                this.processes = ['lint', 'test', 'build'];
                this.currentProcess = -1;
                this.processLabels = this.processes.map((process, index) => {
                    const label = createTextSprite(process, 
                        new THREE.Vector3(position.x - 1 + index, position.y + 1, position.z));
                    label.visible = false;
                    scene.add(label);
                    return label;
                });
            }

            async runProcess() {
                this.currentProcess = -1;
                for (let i = 0; i < this.processes.length; i++) {
                    this.currentProcess = i;
                    this.processLabels[i].visible = true;
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ⏳`,
                        this.processLabels[i].position
                    );
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ✓`,
                        this.processLabels[i].position
                    );
                }
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            reset() {
                this.processLabels.forEach(label => {
                    label.visible = false;
                });
                this.currentProcess = -1;
            }
        }

        // Create flows
        const flows = {
            gitPush: new ParticleFlow(components.local.mesh.position, components.github.mesh.position),
            prToActions: new ParticleFlow(new THREE.Vector3(-4, 0, 0), new THREE.Vector3(-8, 6, 0), 0xFFC107),  // PR to GitHub Actions
            actionsToBuilder: new ParticleFlow(new THREE.Vector3(-8, 6, 0), new THREE.Vector3(-8, -8, 0), 0xFF9800),  // GitHub Actions to Build Server
            deployTest: new ParticleFlow(components.buildServer.mesh.position, components.test.mesh.position, 0x9C27B0),
            deployProd: new ParticleFlow(components.test.mesh.position, components.prod.mesh.position, 0xF44336)
        };

        const githubActions = new GitHubActions(components.github.mesh.position);

        // Pipeline state
        let pipelineState = {
            canPush: true,
            canCreatePR: false,
            isProcessing: false
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            TWEEN.update();

            // Update flows
            Object.values(flows).forEach(flow => flow.update());

            // Update labels to face camera
            Object.values(components).forEach(component => {
                component.label.quaternion.copy(camera.quaternion);
            });
            actionLabels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle component clicking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Get all meshes in the scene for intersection testing
            const allMeshes = [];
            scene.traverse((object) => {
                if (object.isMesh) {
                    allMeshes.push(object);
                }
            });
            const intersects = raycaster.intersectObjects(allMeshes);

            if (intersects.length > 0 && !pipelineState.isProcessing) {
                const object = intersects[0].object;
                // Find the root component by traversing up the parent chain
                let current = object;
                while (current && !current.userData.component) {
                    current = current.parent;
                }
                
                if (current && current.userData.component) {
                    const component = current.userData.component;
                    component.highlight();

                    if (component === components.local && pipelineState.canPush) {
                        // Handle git push
                        pipelineState.isProcessing = true;
                        showStatus('Pushing code changes to GitHub...');
                        flows.gitPush.startFlow(() => {
                            showStatus('Code pushed successfully! Click GitHub to create PR');
                            pipelineState.canPush = false;
                            pipelineState.canCreatePR = true;
                            pipelineState.isProcessing = false;
                        });
                    } 
                    else if (component === components.github && pipelineState.canCreatePR) {
                        // Handle PR creation
                        const handlePRCreation = async () => {
                            try {
                                pipelineState.isProcessing = true;
                                pipelineState.canCreatePR = false;
                                showStatus('Creating Pull Request...');

                                // Create PR visualization
                                if (activePR) {
                                    scene.remove(activePR.mesh);
                                    scene.remove(activePR.label);
                                }
                                activePR = new Component(
                                    createPullRequest,
                                    new THREE.Vector3(-4, 0, 0),
                                    'Pull Request',
                                    0xFFEB3B
                                );

                                // Show PR triggering GitHub Actions
                                showStatus('PR triggering GitHub Actions...');
                                flows.prToActions.startFlow(async () => {
                                    // Highlight GitHub Actions
                                    components.githubActions.highlight();
                                    showStatus('GitHub Actions detected new PR...');
                                    
                                    // Animate GitHub Actions gears
                                    components.githubActions.mesh.children.forEach((child, index) => {
                                        if (index > 0) { // Skip the central hexagon
                                            const rotation = new TWEEN.Tween(child.rotation)
                                                .to({ z: Math.PI * 2 }, 2000)
                                                .repeat(2)
                                                .start();
                                        }
                                    });

                                    // Wait for GitHub Actions to process
                                    await new Promise(resolve => setTimeout(resolve, 2000));
                                    showStatus('GitHub Actions dispatching jobs to Build Server...');

                                    // Show GitHub Actions triggering Build Server
                                    flows.actionsToBuilder.startFlow(async () => {
                                        components.buildServer.highlight();
                                        showStatus('Build Server received jobs from GitHub Actions...');
                                        await new Promise(resolve => setTimeout(resolve, 1000));
                                    });
                                });

                                // Wait for animations to complete
                                await new Promise(resolve => setTimeout(resolve, 4000));
                                showStatus('Starting CI/CD pipeline...');

                                // Start build process
                                const runBuildStep = async (status, message, delay) => {
                                    status.visible = true;
                                    showStatus(message);
                                    await new Promise(resolve => setTimeout(resolve, delay));
                                    status.visible = false;
                                };

                                components.buildServer.highlight();
                                await runBuildStep(buildStatuses.lint, 'GitHub Actions: Running linter...', 2000);
                                await runBuildStep(buildStatuses.test, 'GitHub Actions: Running tests...', 2000);
                                await runBuildStep(buildStatuses.build, 'GitHub Actions: Building...', 2000);

                                // Deploy to test
                                showStatus('Build successful! Deploying to Test...');
                                
                                // Continue with deployment flow
                                flows.deployTest.startFlow(() => {
                                    showStatus('Test deployment successful! Deploying to Production...');
                                    flows.deployProd.startFlow(() => {
                                        showStatus('Deployment complete! Ready for next changes.');
                                        pipelineState.isProcessing = false;
                                        pipelineState.canPush = true;
                                        
                                        if (activePR) {
                                            scene.remove(activePR.mesh);
                                            scene.remove(activePR.label);
                                            activePR = null;
                                        }
                                    });
                                });
                            } catch (error) {
                                console.error('Error in PR creation process:', error);
                                showStatus('Error in pipeline. Please try again.');
                                pipelineState.isProcessing = false;
                                pipelineState.canPush = true;
                                
                                if (activePR) {
                                    scene.remove(activePR.mesh);
                                    scene.remove(activePR.label);
                                    activePR = null;
                                }
                            }
                        };

                        // Start the async process
                        handlePRCreation();
                    }
                }
            }
        });

        animate();
    </script>
</body>
</html>