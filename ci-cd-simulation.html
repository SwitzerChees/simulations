<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['monospace']
                    },
                }
            }
        }
    </script>
</head>
<body class="m-0 overflow-hidden font-mono">
    <canvas class="block"></canvas>
    <div id="history" class="absolute top-2.5 left-2.5 w-[300px] max-h-[80vh] overflow-y-auto bg-white/90 p-2.5 rounded-md shadow-md">
        <h3 class="m-0 mb-2.5 text-lg font-semibold">CI/CD Pipeline Simulation</h3>
        <div class="mb-2.5 text-sm text-gray-600">Click components to interact</div>
        <div id="historyLog" class="flex flex-col gap-1.5"></div>
    </div>
    <div id="controls" class="absolute top-2.5 right-2.5 bg-white/90 p-2.5 rounded-md shadow-md flex flex-col gap-1.5">
        <button id="commitButton" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded transition-colors duration-200 cursor-pointer">Commit Changes</button>
        <button id="pushButton" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded transition-colors duration-200 cursor-pointer">Git Push</button>
        <button id="createPRButton" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors duration-200 cursor-pointer">Create PR</button>
    </div>
    <div id="status" class="absolute bottom-5 left-1/2 -translate-x-1/2 bg-white/90 px-8 py-4 rounded-md shadow-md text-gray-800 text-lg text-center opacity-0 transition-opacity duration-300">Ready</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // Status and history management
        const showStatus = (message) => {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
            historySystem.addAction(message);
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Component focus system
        const focusSystem = {
            currentComponent: null,
            transitionDuration: 1000, // ms
            
            focusComponent: function(component) {
                if (!component || !component.mesh) return;
                this.currentComponent = component;
                
                // Smoothly move camera target to component
                new TWEEN.Tween(controls.target)
                    .to(component.mesh.position, this.transitionDuration)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .start();
            },

            focusSequence: async function(fromComponent, toComponent, duration = 2000) {
                // Focus on sending component
                this.focusComponent(fromComponent);
                
                // Wait for the first focus to complete
                await new Promise(resolve => setTimeout(resolve, this.transitionDuration));
                
                // Then focus on receiving component
                setTimeout(() => {
                    this.focusComponent(toComponent);
                }, duration - this.transitionDuration);
            }
        };
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Text sprite creation helper
        function createTextSprite(text, position, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.font = '24px Arial';
            context.fillStyle = '#333333';
            context.textAlign = 'center';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(scale * 4, scale * 2, 1);
            return sprite;
        }

        // Enhanced Materials with environment mapping
        const envMap = new THREE.CubeTextureLoader()
            .setPath('https://threejs.org/examples/textures/cube/Bridge2/')
            .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);

        const createMetalMaterial = (color, roughness = 0.2) => {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.9,
                roughness: roughness,
                envMap: envMap,
                envMapIntensity: 1
            });
        };

        // Components
        class Component {
            constructor(createGeometryFn, position, name, color) {
                const group = createGeometryFn(color);
                this.mesh = group;
                this.mesh.position.copy(position);
                this.name = name;
                this.mesh.userData.component = this;

                // Add invisible bounding box for larger hit area
                const boundingBox = new THREE.Box3().setFromObject(group);
                const size = boundingBox.getSize(new THREE.Vector3());
                const boxGeometry = new THREE.BoxGeometry(
                    size.x * 1.75, // 1.75x size for balanced hitbox
                    size.y * 1.75,
                    size.z * 1.75
                );
                const boxMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    side: THREE.BackSide
                });
                this.hitbox = new THREE.Mesh(boxGeometry, boxMaterial);
                this.hitbox.userData.rootComponent = this;
                group.add(this.hitbox);

                // Add component reference to all child meshes
                this.mesh.traverse((child) => {
                    child.userData.rootComponent = this;
                });
                scene.add(this.mesh);

                // Add component label
                const labelPos = position.clone();
                labelPos.y += 3;
                this.label = createTextSprite(name, labelPos);
                scene.add(this.label);
            }

            highlight(permanent = false, color = 0x00ff00) {
                const highlightColor = new THREE.Color(color);
                this.mesh.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        if (!permanent) {
                            const originalColor = child.material.emissive.clone();
                            child.material.emissive = highlightColor;
                            setTimeout(() => {
                                child.material.emissive = originalColor;
                            }, 1000);
                        } else {
                            child.material.emissive = highlightColor;
                        }
                    }
                });
            }
        }

        // Local Git - Repository with branching structure
        const createLocalGit = (color) => {
            const group = new THREE.Group();
            
            // Main cylinder (trunk)
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 3, 8),
                createMetalMaterial(color)
            );
            group.add(trunk);

            // Branches
            for (let i = 0; i < 3; i++) {
                const branch = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 2, 8),
                    createMetalMaterial(color)
                );
                branch.position.y = -0.5 + i;
                branch.rotation.z = Math.PI / 3;
                branch.position.x = 0.8;
                group.add(branch);
            }

            return group;
        };

        // GitHub - Octocat-inspired shape
        const createGitHub = (color) => {
            const group = new THREE.Group();

            // Body (octagon)
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 2, 8),
                createMetalMaterial(color)
            );
            group.add(body);

            // Tentacles
            for (let i = 0; i < 8; i++) {
                const tentacle = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.1, 8, 6),
                    createMetalMaterial(color)
                );
                tentacle.rotation.y = (i / 8) * Math.PI * 2;
                tentacle.position.y = -1;
                group.add(tentacle);
            }

            return group;
        };

        // Build Server - Server rack with glowing components
        const createBuildServer = (color) => {
            const group = new THREE.Group();

            // Main frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(3, 4, 2),
                createMetalMaterial(color, 0.5)
            );
            group.add(frame);

            // Glowing server units
            for (let i = 0; i < 4; i++) {
                const unit = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.5, 1.5),
                    new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    })
                );
                unit.position.y = -1.5 + i;
                group.add(unit);
            }

            return group;
        };

        // Test Environment - Molecular structure
        const createTestEnv = (color) => {
            const group = new THREE.Group();

            // Central sphere
            const center = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                createMetalMaterial(color)
            );
            group.add(center);

            // Orbiting test nodes
            for (let i = 0; i < 4; i++) {
                const orbit = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 4) * Math.PI * 2;
                orbit.position.set(
                    Math.cos(angle) * 1.5,
                    Math.sin(angle) * 1.5,
                    0
                );
                group.add(orbit);

                // Connection to center
                const line = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                    createMetalMaterial(color)
                );
                line.position.set(
                    Math.cos(angle) * 0.75,
                    Math.sin(angle) * 0.75,
                    0
                );
                line.lookAt(orbit.position);
                group.add(line);
            }

            return group;
        };

        // Production - Cloud-like structure
        const createProduction = (color) => {
            const group = new THREE.Group();

            // Main cloud shapes
            const shapes = [
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.SphereGeometry(0.8, 16, 16),
            ];

            const positions = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-1, 0.2, 0),
                new THREE.Vector3(1, 0.2, 0),
            ];

            shapes.forEach((shape, i) => {
                const cloud = new THREE.Mesh(
                    shape,
                    createMetalMaterial(color)
                );
                cloud.position.copy(positions[i]);
                group.add(cloud);
            });

            // Add some smaller detail spheres
            for (let i = 0; i < 5; i++) {
                const detail = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    createMetalMaterial(color)
                );
                const angle = (i / 5) * Math.PI * 2;
                detail.position.set(
                    Math.cos(angle) * 1.2,
                    Math.sin(angle) * 0.3 + 0.5,
                    0
                );
                group.add(detail);
            }

            return group;
        };

        // Create GitHub Actions component
        const createGitHubActions = (color) => {
            const group = new THREE.Group();

            // Central hexagon
            const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 6);
            const material = createMetalMaterial(color);
            const hexagon = new THREE.Mesh(geometry, material);
            hexagon.rotation.x = Math.PI / 2;
            group.add(hexagon);

            // Orbiting gears
            const gearCount = 6;
            for (let i = 0; i < gearCount; i++) {
                const gearGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
                const gear = new THREE.Mesh(gearGeometry, material);
                const angle = (i / gearCount) * Math.PI * 2;
                gear.position.x = Math.cos(angle) * 2;
                gear.position.z = Math.sin(angle) * 2;
                gear.rotation.x = Math.PI / 2;
                group.add(gear);
            }

            return group;
        };

        // Create Pull Request component
        const createPullRequest = (color) => {
            const group = new THREE.Group();

            // PR document shape
            const document = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2, 0.2),
                createMetalMaterial(color)
            );
            group.add(document);

            // Add lines of "text"
            const textMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.1, 0.1),
                    textMat
                );
                line.position.y = 0.5 - (i * 0.4);
                group.add(line);
            }

            return group;
        };

        // Build Server Status Display
        const createBuildStatus = (text, position, color) => {
            const label = createTextSprite(text, position);
            label.visible = false;
            scene.add(label);
            return label;
        };

        // Create developer component
        const createDeveloper = (color) => {
            const group = new THREE.Group();

            // Developer head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 32, 32),
                createMetalMaterial(color)
            );
            head.position.y = 1.2;
            group.add(head);

            // Developer body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.8, 2, 8),
                createMetalMaterial(color)
            );
            group.add(body);

            // Developer arms
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const leftArm = new THREE.Mesh(armGeometry, createMetalMaterial(color));
            leftArm.position.set(-0.8, 0.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, createMetalMaterial(color));
            rightArm.position.set(0.8, 0.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            group.add(rightArm);

            return group;
        };

        // Create components with new layout
        const components = {
            developer: new Component(
                createDeveloper,
                new THREE.Vector3(-24, 0, 0),
                'Developer',
                0x9C27B0
            ),
            local: new Component(
                createLocalGit,
                new THREE.Vector3(-16, 0, 0),
                'Local Git',
                0x4CAF50
            ),
            github: new Component(
                createGitHub,
                new THREE.Vector3(-8, 0, 0),
                'GitHub',
                0x2196F3
            ),
            githubActions: new Component(
                createGitHubActions,
                new THREE.Vector3(-8, 6, 0),
                'GitHub Actions',
                0xFFC107
            ),
            buildServer: new Component(
                createBuildServer,
                new THREE.Vector3(-8, -8, 0),
                'Build Server',
                0xFF9800
            ),
            test: new Component(
                createTestEnv,
                new THREE.Vector3(8, 0, 0),
                'Test Env',
                0x9C27B0
            ),
            prod: new Component(
                createProduction,
                new THREE.Vector3(16, 0, 0),
                'Production',
                0xF44336
            )
        };

        // Create build status indicators
        const buildStatuses = {
            lint: createBuildStatus('Linting...', new THREE.Vector3(-10, -6, 0), 0xFFEB3B),
            test: createBuildStatus('Testing...', new THREE.Vector3(-8, -6, 0), 0x4CAF50),
            build: createBuildStatus('Building...', new THREE.Vector3(-6, -6, 0), 0x2196F3)
        };

        let activePR = null;

        // Create connection lines and action labels
        const connectionMaterials = {
            inactive: new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 }),  // Light gray for inactive
            active: new THREE.LineBasicMaterial({ color: 0x4CAF50, linewidth: 2 })     // Softer green for active
        };
        const connections = [];
        const actionLabels = [];

        function createConnection(start, end, actionText) {
            // Create connection line
            const points = [];
            points.push(start.mesh.position);
            points.push(end.mesh.position);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, connectionMaterials.inactive);
            line.userData.originalColor = connectionMaterials.inactive;
            scene.add(line);
            connections.push(line);

            // Create action label
            const midPoint = new THREE.Vector3().lerpVectors(start.mesh.position, end.mesh.position, 0.5);
            midPoint.y += 1;
            const actionLabel = createTextSprite(actionText, midPoint, 0.7);
            scene.add(actionLabel);
            actionLabels.push(actionLabel);

            return line;
        }

        // Create connections between components with action labels
        const pathConnections = {
            devToLocal: createConnection(components.developer, components.local, 'code'),
            gitPush: createConnection(components.local, components.github, 'git push'),
            prToActions: createConnection(components.github, components.githubActions, 'PR Trigger'),
            actionsToBuild: createConnection(components.githubActions, components.buildServer, 'CI Jobs'),
            buildToTest: createConnection(components.buildServer, components.test, 'Deploy to Test'),
            testToProd: createConnection(components.test, components.prod, 'Deploy to Prod'),
            feedbackToDev: createConnection(components.buildServer, components.developer, 'CI Feedback')
        };

        // Function to update path colors
        function updatePathColors(completedPaths) {
            Object.keys(pathConnections).forEach(path => {
                pathConnections[path].material = completedPaths.includes(path) ? 
                    connectionMaterials.active : connectionMaterials.inactive;
            });
        }



        // Particle system for code flow
        class ParticleFlow {
            constructor(start, end, color = 0x00ff00) {
                this.startPos = start;
                this.endPos = end;
                this.color = color;
                this.particles = [];
                this.progress = 0;
                this.active = false;
                this.onComplete = null;
                this.createParticles();
            }

            createParticles() {
                // Create multiple particles for a trail effect
                for (let i = 0; i < 10; i++) {  // More particles
                    const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);  // Bigger particles
                    const material = new THREE.MeshPhongMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.8,
                        emissive: this.color,  // Add glow effect
                        emissiveIntensity: 0.5
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        offset: i * 0.1  // Tighter spacing
                    });
                }
            }

            startFlow(onComplete) {
                this.active = true;
                this.progress = 0;
                this.particles.forEach(p => p.mesh.visible = true);
                this.onComplete = onComplete;
            }

            update() {
                if (!this.active) return;

                this.progress += 0.005; // Slower animation

                this.particles.forEach(particle => {
                    let particleProgress = this.progress - particle.offset;
                    if (particleProgress < 0) particleProgress = 0;
                    if (particleProgress > 1) particleProgress = 1;

                    particle.mesh.position.lerpVectors(
                        this.startPos,
                        this.endPos,
                        particleProgress
                    );

                    // Fade particles at start and end
                    const fade = 1 - Math.abs(particleProgress - 0.5) * 2;
                    particle.mesh.material.opacity = fade * 0.8;
                });

                if (this.progress >= 1.15) { // Account for trail length
                    this.active = false;
                    this.particles.forEach(p => p.mesh.visible = false);
                    if (this.onComplete) this.onComplete();
                }
            }
        }

        // GitHub Actions visualization
        class GitHubActions {
            constructor(position) {
                this.position = position.clone();
                this.position.y += 1;
                this.processes = ['lint', 'test', 'build'];
                this.currentProcess = -1;
                this.processLabels = this.processes.map((process, index) => {
                    const label = createTextSprite(process, 
                        new THREE.Vector3(position.x - 1 + index, position.y + 1, position.z));
                    label.visible = false;
                    scene.add(label);
                    return label;
                });
            }

            async runProcess() {
                this.currentProcess = -1;
                for (let i = 0; i < this.processes.length; i++) {
                    this.currentProcess = i;
                    this.processLabels[i].visible = true;
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ⏳`,
                        this.processLabels[i].position
                    );
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.processLabels[i].material.map.dispose();
                    this.processLabels[i] = createTextSprite(
                        `${this.processes[i]} ✓`,
                        this.processLabels[i].position
                    );
                }
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            reset() {
                this.processLabels.forEach(label => {
                    label.visible = false;
                });
                this.currentProcess = -1;
            }
        }

        // Create flows
        const flows = {
            devToLocal: new ParticleFlow(components.developer.mesh.position, components.local.mesh.position),
            gitPush: new ParticleFlow(components.local.mesh.position, components.github.mesh.position),
            prToActions: new ParticleFlow(new THREE.Vector3(-4, 0, 0), new THREE.Vector3(-8, 6, 0), 0xFFC107),  // PR to GitHub Actions
            actionsToBuilder: new ParticleFlow(new THREE.Vector3(-8, 6, 0), new THREE.Vector3(-8, -8, 0), 0xFF9800),  // GitHub Actions to Build Server
            deployTest: new ParticleFlow(components.buildServer.mesh.position, components.test.mesh.position, 0x9C27B0),
            deployProd: new ParticleFlow(components.test.mesh.position, components.prod.mesh.position, 0xF44336),
            feedbackToDev: new ParticleFlow(components.buildServer.mesh.position, components.developer.mesh.position, 0xFF0000)  // Red for failure feedback
        };

        const githubActions = new GitHubActions(components.github.mesh.position);

        // History log system
        const historySystem = {
            actions: [],
            addAction: function(action) {
                const timestamp = new Date().toLocaleTimeString();
                const actionItem = { timestamp, action, type: pipelineState.currentAction };
                this.actions.push(actionItem);
                this.updateHistoryLog();
            },
            updateHistoryLog: function() {
                const historyLog = document.getElementById('historyLog');
                const actionItem = this.actions[this.actions.length - 1];
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-2 bg-gray-50 rounded border-l-4 border-blue-500 mb-1.5 hover:bg-gray-100 transition-colors duration-200';
                
                const timeSpan = document.createElement('span');
                timeSpan.className = 'text-gray-600 text-sm';
                timeSpan.textContent = actionItem.timestamp;
                
                const actionSpan = document.createElement('div');
                actionSpan.className = 'mt-0.5';
                actionSpan.textContent = actionItem.action;
                
                const replayButton = document.createElement('button');
                replayButton.textContent = 'Replay';
                replayButton.className = 'mt-1.5 px-2 py-1 bg-green-500 hover:bg-green-600 text-white rounded text-xs cursor-pointer transition-colors duration-200';
                replayButton.onclick = () => this.replayAction(actionItem);
                
                itemDiv.appendChild(timeSpan);
                itemDiv.appendChild(actionSpan);
                itemDiv.appendChild(replayButton);
                historyLog.appendChild(itemDiv);
                
                // Scroll to bottom
                historyLog.scrollTop = historyLog.scrollHeight;
            },
            replayAction: async function(actionItem) {
                if (pipelineState.isProcessing) {
                    alert('Please wait for the current action to complete');
                    return;
                }
                
                switch(actionItem.type) {
                    case 'commit':
                        await handleCommit();
                        break;
                    case 'push':
                        if (pipelineState.hasLocalChanges) {
                            pipelineState.currentAction = 'push';
                            components.local.highlight();
                            flows.gitPush.startFlow(() => {
                                showStatus('Code pushed successfully! Click GitHub to create PR');
                                pipelineState.canPush = false;
                                pipelineState.canCreatePR = true;
                                pipelineState.isProcessing = false;
                            });
                        }
                        break;
                    case 'pr':
                        if (pipelineState.canCreatePR) {
                            handlePRCreation();
                        }
                        break;
                }
            }
        };

        // Pipeline state
        let pipelineState = {
            canPush: true,
            canCreatePR: false,
            isProcessing: false,
            canCommit: true,
            hasLocalChanges: false,
            currentAction: null
        };



        // Commit button handler
        const handleCommit = async () => {
            if (!pipelineState.canCommit || pipelineState.isProcessing) {
                showStatus('Please wait for the current process to complete...');
                return;
            }

            pipelineState.isProcessing = true;
            pipelineState.canCommit = false;
            pipelineState.currentAction = 'commit';

            // Start the commit flow
            showStatus('Developer committing changes...');
            updatePathColors(['devToLocal']);
            components.developer.highlight();

            // Simulate coding activity
            flows.devToLocal.startFlow(async () => {
                components.local.highlight();
                await new Promise(resolve => setTimeout(resolve, 1000));
                showStatus('Changes committed to local repository');
                pipelineState.hasLocalChanges = true;
                pipelineState.isProcessing = false;
                pipelineState.canCommit = true;
                pipelineState.canPush = true;
            });
        };

        // Handle commit button click
        document.getElementById('commitButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing) {
                handleCommit();
                focusSystem.focusSequence(components.developer, components.local);
            }
        });

        // Handle push button click
        document.getElementById('pushButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canPush && pipelineState.hasLocalChanges) {
                handleGitPush();
                focusSystem.focusSequence(components.local, components.github);
            } else {
                showStatus('Cannot push: Ensure you have committed changes and no process is running');
            }
        });

        // Handle PR button click
        document.getElementById('createPRButton').addEventListener('click', () => {
            if (!pipelineState.isProcessing && pipelineState.canCreatePR) {
                handlePRCreation();
                focusSystem.focusSequence(components.github, components.githubActions);
            } else {
                showStatus('Cannot create PR: Ensure you have pushed changes and no process is running');
            }
        });

        // PR Creation Handler
        const handlePRCreation = async () => {
            try {
                pipelineState.isProcessing = true;
                pipelineState.currentAction = 'pr';
                pipelineState.canCreatePR = false;
                showStatus('Creating Pull Request...');
                components.github.highlight();
                
                // After a short delay, highlight the target
                setTimeout(() => {
                    components.githubActions.highlight();
                }, 1000);

                // Create PR visualization
                if (activePR) {
                    scene.remove(activePR.mesh);
                    scene.remove(activePR.label);
                }
                activePR = new Component(
                    createPullRequest,
                    new THREE.Vector3(-4, 0, 0),
                    'Pull Request',
                    0xFFEB3B
                );

                // Reset all paths to inactive
                updatePathColors([]);
                
                // Show PR triggering GitHub Actions
                showStatus('PR triggering GitHub Actions...');
                updatePathColors(['prToActions']);
                flows.prToActions.startFlow(async () => {
                    // Highlight GitHub Actions
                    components.githubActions.highlight();
                    showStatus('GitHub Actions detected new PR...');
                    
                    try {
                        components.buildServer.highlight();
                        await runBuildStep(buildStatuses.lint, 'GitHub Actions: Running linter...', 2000);
                        await runBuildStep(buildStatuses.test, 'GitHub Actions: Running tests...', 2000);
                        await runBuildStep(buildStatuses.build, 'GitHub Actions: Building...', 2000);
                        
                        // Show success and enable deployment
                        showStatus('CI pipeline passed! PR ready for review.');
                        pipelineState.isProcessing = false;
                    } catch (error) {
                        // Show failure feedback
                        showStatus(`CI Failed: ${error.message}`);
                        components.developer.highlight();
                        updatePathColors(['prToActions', 'actionsToBuild', 'feedbackToDev']);
                        
                        // Reset state
                        pipelineState.isProcessing = false;
                        pipelineState.canCreatePR = true;
                    }
                });
            } catch (error) {
                console.error('Error in PR creation process:', error);
                showStatus('Error in pipeline. Please try again.');
                pipelineState.isProcessing = false;
                pipelineState.canPush = true;
            }
        };

        // Git push handler
        const handleGitPush = async () => {
            pipelineState.isProcessing = true;
            pipelineState.currentAction = 'push';
            showStatus('Pushing to GitHub...');
            
            try {
                // Start particle flow animation and highlight source
                components.local.highlight();
                flows.gitPush.startFlow(() => {
                    // When flow starts, highlight target
                    components.github.highlight();
                });
                
                // Simulate network delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Update state
                pipelineState.canPush = false;
                pipelineState.canCreatePR = true;
                pipelineState.hasLocalChanges = false;
                
                // Show success feedback
                showStatus('Successfully pushed to GitHub');
                
                // Update connection colors
                updatePathColors(['gitPush']);
                
            } catch (error) {
                console.error('Error in git push:', error);
                showStatus('Error pushing to GitHub. Please try again.');
            } finally {
                pipelineState.isProcessing = false;
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            TWEEN.update();

            // Update flows
            Object.values(flows).forEach(flow => flow.update());

            // Update labels to face camera
            Object.values(components).forEach(component => {
                component.label.quaternion.copy(camera.quaternion);
            });
            actionLabels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle component clicking and hovering
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredComponent = null;

        // Mouse move handler for hover effect
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const allMeshes = [];
            scene.traverse((object) => {
                if (object.isMesh) {
                    allMeshes.push(object);
                }
            });
            const intersects = raycaster.intersectObjects(allMeshes);

            let foundComponent = null;
            if (intersects.length > 0) {
                const object = intersects[0].object;
                let current = object;
                while (current && !current.userData.rootComponent) {
                    current = current.parent;
                }
                if (current && current.userData.rootComponent) {
                    foundComponent = current.userData.rootComponent;
                }
            }

            // Update hover highlighting
            if (foundComponent !== hoveredComponent) {
                // Remove highlight from previously hovered component
                if (hoveredComponent) {
                    hoveredComponent.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                }
                // Add highlight to newly hovered component
                if (foundComponent) {
                    foundComponent.mesh.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x444444);
                        }
                    });
                }
                hoveredComponent = foundComponent;
            }
        });

        window.addEventListener('click', async (event) => { 
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Get all meshes in the scene for intersection testing
            const allMeshes = [];
            scene.traverse((object) => {
                if (object.isMesh) {
                    allMeshes.push(object);
                }
            });
            const intersects = raycaster.intersectObjects(allMeshes);

            if (intersects.length > 0 && !pipelineState.isProcessing) {
                const object = intersects[0].object;
                // Find the root component by traversing up the parent chain
                let current = object;
                while (current && !current.userData.component) {
                    current = current.parent;
                }
                
                if (current && current.userData.rootComponent) {
                    const component = current.userData.rootComponent;
                    component.highlight();
                    focusSystem.focusComponent(component);
                }
            }

            animate();
        });

        animate();
    </script>
</body>
</html>